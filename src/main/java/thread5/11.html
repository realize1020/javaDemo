<div class="Content detail-content-new">
    <!--关注-->
    <div class="fixtitle" style="display: none;">
        <div class="clearfix Page">
            <h3 class="fl title">Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结</h3>
            <div class="messbox fr">
                <a id="checkFollow1_13616762" class="follow-1 checkFollow on">关注</a>
                <a href="https://blog.51cto.com/u_13626762" class="name" target="_blank" title="Hollis在51CTO">Hollis在51CTO</a>
                <strong>
                    <a href="https://blog.51cto.com/u_13626762" class="avatar" target="_blank">
                        <img class="is-vip-img is-vip-img-4" data-uid="13616762" src="https://s2.51cto.com/oss/201904/09/9210cdc5924b0d7be8b3599dc11eb6be.jpg?x-oss-process=image/format,webp/ignore-error,1">
                    </a>
                </strong>
            </div>
        </div>
    </div>
    <!--大模块引入-->
    <div class="clearfix Page" id="page_center" style="position:relative;">
        <aside class="detail-content-directory common-content-directory">
            <!-- 文章目录 -->
            <section class="common-section common-spacing table-contents" style="background:none">
                <div class="clearfix common-sub-title">
                    <strong title="文章目录">文章目录</strong>
                    <i class="iconblog blogquxiao18" id="closeDirectory"></i>
                </div>
                <div class="directory" id="directory-parent2">
                    <ul class="directory-list directory-list-left" id="directory-left">
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h1">
                                                                        分布式锁入门                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h3">
                                                                        超时设置                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h5">
                                                                        释放了不是自己加的锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h7">
                                                                        正确设置锁超时                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h9">
                                                                        加解锁代码位置有讲究                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h11">
                                                                        实现可重入锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h12">
                                                                        Redis Hash 可重入锁                                </span>
                            </div>
                        </li>
                        <li class="lv3">
                            <div class="title">
                                <span data-id="#h13">
                                                                        加锁逻辑                                </span>
                            </div>
                        </li>
                        <li class="lv3">
                            <div class="title">
                                <span data-id="#h14">
                                                                        解锁逻辑                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h16">
                                                                        主从架构带来的问题                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h18">
                                                                        什么是 Redlock                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h19">
                                                                        Redlock 是与非                                </span>
                            </div>
                        </li>
                        <li class="lv3">
                            <div class="title">
                                <span data-id="#h20">
                                                                        Martin 的结论                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h21">
                                                                        Redis 作者 Antirez 的反驳                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h23">
                                                                        Redisson 分布式锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h24">
                                                                        失败无限重试                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h25">
                                                                        失败超时重试，自动续命                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h26">
                                                                        超时自动释放锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h27">
                                                                        超时重试，自动解锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h28">
                                                                        Watch Dog 自动延时                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h29">
                                                                        源码导读                                </span>
                            </div>
                        </li>
                        <li class="lv1 on">
                            <div class="title">
                                <span data-id="#h30">
                                                                        、                                </span>
                            </div>
                        </li>
                    </ul>
                </div>
            </section>
        </aside>
        <article class="detail-content-left">
            <div class="common-section common-spacing mb30 article-detail">
                <div class="title">
                    <h1>Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结</h1>
                    <span class="reprint">转载</span>
                </div>
                <div class="messbox">
                    <p class="clearfix mess-line1">
                        <a class="fl" href="https://blog.51cto.com/u_13626762" rel="nofollow">Hollis在51CTO</a>
                        <time class="fl" pubdate="2021-12-07 17:05:11">2021-12-07 17:05:11</time>
                    </p>
                    <p class="clearfix mess-tag">
                        <strong class="fl">
                            <em class="fl">文章标签</em>
                            <a href="https://blog.51cto.com/topic/fenbushi.html" class="fl  shence_tag" target="_blank">分布式</a>
                            <a href="https://blog.51cto.com/topic/redis.html" class="fl  shence_tag" target="_blank">redis</a>
                            <a href="https://blog.51cto.com/topic/java.html" class="fl  shence_tag" target="_blank">java</a>
                            <a href="https://blog.51cto.com/topic/the-database-1.html" class="fl  shence_tag" target="_blank">数据库</a>
                            <a href="https://blog.51cto.com/topic/multithreading.html" class="fl  shence_tag" target="_blank">多线程</a>
                        </strong>
                        <strong class="fl">
                            <em class="fl">文章分类</em>
                            <a href="https://blog.51cto.com/nav/ops" class="fl shence_cate" target="_blank" rel="nofollow">运维</a>
                        </strong>
                        <strong class="fl"><em class="fl">阅读数</em><b class="fl">21</b></strong></p>
                </div>
                <div class="article-content-wrap">
                    <div class="artical-content-bak main-content editor-side-new">
                        <div class="con editor-preview-side" id="result" data-version="0"><div class="container am-engine" deep="8"><p><br data-filtered="filtered"></p><p><br data-filtered="filtered"></p><p>Redis 分布式锁使用 SET 指令就可以实现了么？在分布式领域 CAP 理论一直存在。</p><p>分布式锁的门道可没那么简单，我们在网上看到的分布式锁方案可能是有问题的。</p><p>一步步带你深入分布式锁是如何一步步完善，在高并发生产环境中如何正确使用分布式锁。</p><p>在进入正文之前，我们先带着问题去思考：</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>什么时候需要分布式锁？</li><li>加、解锁的代码位置有讲究么？</li><li>如何避免出现锁再也无法删除？</li><li>超时时间设置多少合适呢？</li><li>如何避免锁被其他线程释放</li><li>如何实现重入锁？</li><li>主从架构会带来什么安全问题？</li><li>什么是 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redlock​</code>​</li><li>Redisson 分布式锁最佳实战</li><li>看门狗实现原理</li><li>……<ul><li><br data-filtered="filtered"></li></ul></li></ul><p><strong>什么时候用分布式锁？</strong></p><p>❝说个通俗的例子讲解下什么时候需要分布式锁呢？</p><p>诊所只有一个医生，很多患者前来就诊。</p><p>医生在同一时刻只能给一个患者提供就诊服务。</p><p>如果不是这样的话，就会出现医生在就诊肾亏的「肖菜鸡」准备开药时候患者切换成了脚臭的「谢霸哥」，这时候药就被谢霸哥取走了。</p><p>治肾亏的药被有脚臭的拿去了。</p><p>当并发去读写一个【共享资源】的时候，我们为了保证数据的正确，需要控制同一时刻只有一个线程访问。</p><p><strong>分布式锁就是用来控制同一时刻，只有一个 JVM 进程中的一个线程可以访问被保护的资源。</strong></p><h2 id="h0"><br data-filtered="filtered"></h2><h2 id="h1">分布式锁入门</h2><p>❝65 哥：分布式锁应该满足哪些特性？</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>互斥：在任何给定时刻，只有一个客户端可以持有锁；</li><li>无死锁：任何时刻都有可能获得锁，即使获取锁的客户端崩溃；</li><li>容错：只要大多数 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redis​</code>​的节点都已经启动，客户端就可以获取和释放锁。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p>❝我可以使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SETNX key value​</code>​ 命令是实现「互斥」特性。</p><p>这个命令<span class="userCheck">来自</span>于​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET if Not eXists​</code>​​的缩写，意思是：如果 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​​ 不存在，则设置 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​value​</code>​​ 给这个​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​，否则啥都不做。Redis 官方地址说的：</p><p>命令的返回值：</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>1：设置成功；</li><li>0：key 没有设置成功。<ul><li><br data-filtered="filtered"></li></ul></li></ul><p>如下场景：</p><p>敲代码一天累了，想去放松按摩下肩颈。</p><p>168 号技师最抢手，大家喜欢点，所以并发量大，需要分布式锁控制。</p><p>同一时刻只允许一个「客户」预约 168 技师。</p><p>肖菜鸡申请 168 技师成功：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_0" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&gt; SETNX lock:168 1<br data-filtered="filtered">(integer) 1 # 获取 168 技师成功</div><ul class="pre-numbering" id="code_id_0" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><p>谢霸哥后面到，申请失败：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_1" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&gt; SETNX lock 2<br data-filtered="filtered">(integer) 0 # 客户谢霸哥 2 获取失败</div><ul class="pre-numbering" id="code_id_1" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><p>此刻，申请成功的客户就可以享受 168 技师的肩颈放松服务「共享资源」。</p><p>享受结束后，要及时释放锁，给后来者享受 168 技师的服务机会。</p><p>❝肖菜鸡，考考你如何释放锁呢？</p><p>很简单，使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​​ 删除这个 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​ 就行。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_2" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&gt; DEL lock:168<br data-filtered="filtered">(integer) 1</div><ul class="pre-numbering" id="code_id_2" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><p>❝你见过「龙」么？我见过，因为我被一条龙服务过。</p><p><img src="https://s2.51cto.com/images/blog/202112/07002301_61ae38e56527a53074.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 574px; height: 222px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_分布式"></p><p>肖菜鸡，事情可没这么简单。</p><p>这个方案存在一个存在造成锁无法释放的问题，造成该问题的场景如下：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>客户端所在节点崩溃，无法正确释放锁；</li><li>业务逻辑异常，无法执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​指令。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p>这样，这个锁就会一直占用，锁在我手里，我挂了，这样其他客户端再也拿不到这个锁了。</p><h2 id="h2"><br data-filtered="filtered"></h2><h2 id="h3">超时设置</h2><p>❝我可以在获取锁成功的时候设置一个「超时时间」</p><p>比如设定按摩服务一次 60 分钟，那么在给这个 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​ 加锁的时候设置 60 分钟过期即可：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_3" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&gt; SETNX lock:168 1  // 获取锁<br data-filtered="filtered">(integer) 1<br data-filtered="filtered">&gt; EXPIRE lock:168 60  // 60s 自动删除<br data-filtered="filtered">(integer) 1</div><ul class="pre-numbering" id="code_id_3" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li></ul></pre></div></div></div></div><p>这样，到点后锁自动释放，其他客户就可以继续享受 168 技师按摩服务了。</p><p>❝谁要这么写，就糟透了。</p><p>「加锁」、「设置超时」是两个命令，他们不是原子操作。</p><p><strong>如果出现只执行了第一条，第二条没机会执行就会出现「超时时间」设置失败，依然出现锁无法释放。</strong></p><p>❝那咋办，我想被一条龙服务，要解决这个问题</p><p>Redis 2.6.X 之后，官方拓展了 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET​</code>​ 命令的参数，满足了当 key 不存在则设置 value，同时设置超时时间的语义，并且满足原子性。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_4" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">SET resource_name random_value NX PX 30000</div><ul class="pre-numbering" id="code_id_4" style="display: block;"><li>1.</li></ul></pre></div></div></div></div><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>NX：表示只有 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​resource_name​</code>​ 不存在的时候才能 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET​</code>​ 成功，从而保证只有一个客户端可以获得锁；</li><li>PX 30000：表示这个锁有一个 30 秒自动过期时间。<ul><li><br data-filtered="filtered"></li></ul></li></ul><p>这样写还不够，我们还要防止不能释放不是自己加的锁。我们可以在 value 上做文章。</p><p>继续往下看……</p><h2 id="h4"><br data-filtered="filtered"></h2><h2 id="h5">释放了不是自己加的锁</h2><p>❝这样我能稳妥的享受一条龙服务了么？</p><p>No，还有一种场景会导致<strong>释放别人的锁</strong>：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>客户 1 获取锁成功并设置设置 30 秒超时；</li><li>客户 1 因为一些原因导致执行很慢（网络问题、发生 FullGC……），过了 30 秒依然没执行完，但是锁过期「自动释放了」；</li><li>客户 2 申请加锁成功；</li><li>客户 1 执行完成，执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​ 释放锁指令，这个时候就把客户 2 的锁给释放了。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p>有个关键问题需要解决：自己的锁只能自己来释放。</p><p>❝我要如何删除是自己加的锁呢？</p><p>在执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​ 指令的时候，我们要想办法检查下这个锁是不是自己加的锁再执行删除指令。</p><p><strong>解铃还须系铃人</strong></p><p>❝我在加锁的时候设置一个「唯一标识」作为 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​value​</code>​​ 代表加锁的客户端。​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET resource_name random_value NX PX 30000​</code>​在释放锁的时候，客户端将自己的「唯一标识」与锁上的「标识」比较是否相等，匹配上则删除，否则没有权利释放锁。</p><p>伪代码如下：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_5" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 比对 value 与 唯一标识<br data-filtered="filtered">if (redis.get("lock:168").equals(random_value)){<br data-filtered="filtered">   redis.del("lock:168"); //比对成功则删除<br data-filtered="filtered"> }</div><ul class="pre-numbering" id="code_id_5" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li></ul></pre></div></div></div></div><p>❝有没有想过，这是 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​GET + DEL​</code>​ 指令组合而成的，这里又会涉及到原子性问题。</p><p>我们可以通过 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Lua​</code>​ 脚本来实现，这样判断和删除的过程就是原子操作了。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_6" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 获取锁的 value 与 ARGV[1] 是否匹配，匹配则执行 del<br data-filtered="filtered">if redis.call("get",KEYS[1]) == ARGV[1] then<br data-filtered="filtered">    return redis.call("del",KEYS[1])<br data-filtered="filtered">else<br data-filtered="filtered">    return 0<br data-filtered="filtered">end</div><ul class="pre-numbering" id="code_id_6" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li></ul></pre></div></div></div></div><p>这样通过唯一值设置成 value 标识加锁的客户端很重要，仅使用 DEL 是不安全的，因为一个客户端可能会删除另一个客户端的锁。</p><p>使用上面的脚本，每个锁都用一个随机字符串“签名”，只有当删除锁的客户端的“签名”与锁的 value 匹配的时候，才会删除它。</p><p>官方文档也是这么说的：​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​https://redis.io/topics/distlock​</code>​</p><p>这个方案已经相对完美，我们用的最多的可能就是这个方案了。</p><h2 id="h6"><br data-filtered="filtered"></h2><h2 id="h7">正确设置锁超时</h2><p>❝锁的超时时间怎么计算合适呢？</p><p>这个时间不能瞎写，一般要根据在测试环境多次测试，然后压测多轮之后，比如计算出平均执行时间 200 ms。</p><p>那么锁的<strong>超时时间就放大为平均执行时间的 3~5 倍。</strong></p><p>❝为啥要放放大呢？</p><p>因为如果锁的操作逻辑中有网络 IO 操作、JVM FullGC 等，线上的网络不会总一帆风顺，我们要给网络抖动留有缓冲时间。</p><p>❝那我设置更大一点，比如设置 1 小时不是更安全？</p><p>不要钻牛角，多大算大？</p><p>设置时间过长，一旦发生宕机重启，就意味着 1 小时内，分布式锁的服务全部节点不可用。</p><p>你要让运维手动删除这个锁么？</p><p>只要运维真的不会打你。</p><p>❝有没有完美的方案呢？不管时间怎么设置都不大合适。</p><p>我们可以让获得锁的线程开启一个<strong>守护线程</strong>，用来给快要过期的锁「续航」。</p><p>加锁的时候设置一个过期时间，同时客户端开启一个「守护线程」，定时去检测这个锁的失效时间。</p><p><strong>如果快要过期，但是业务逻辑还没执行完成，自动对这个锁进行续期，重新设置过期时间。</strong></p><p>❝这个道理行得通，可我写不出。</p><p>别慌，已经有一个库把这些工作都封装好了他叫 <strong>Redisson</strong>。</p><p>在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p><p>❝一路优化下来，方案似乎比较「严谨」了，抽象出对应的模型如下。</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>通过 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET lock_resource_name random_value NX PX expire_time​</code>​，同时启动守护线程为快要过期但还没执行完的客户端的锁续命;</li><li>客户端执行业务逻辑操作共享资源；</li><li>通过 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Lua​</code>​ 脚本释放锁，先 get 判断锁是否是自己加的，再执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p><img src="https://s2.51cto.com/images/blog/202112/07002301_61ae38e57532654850.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 691px; height: 386px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_java_02"></p><p>这个方案实际上已经比较完美，能写到这一步已经打败 90% 的程序猿了。</p><p>但是对于追求极致的程序员来说还远远不够：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>可重入锁如何实现？</li><li>主从架构崩溃恢复导致锁丢失如何解决？</li><li>客户端加锁的位置有门道么？<ol><li><br data-filtered="filtered"></li></ol></li></ol><h2 id="h8"><br data-filtered="filtered"></h2><h2 id="h9">加解锁代码位置有讲究</h2><p>根据前面的分析，我们已经有了一个「相对严谨」的分布式锁了。</p><p>于是「谢霸哥」就写了如下代码将分布式锁运用到项目中，以下是伪代码逻辑：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_7" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">public void doSomething() {<br data-filtered="filtered">  redisLock.lock(); // 上锁<br data-filtered="filtered">    try {<br data-filtered="filtered">        // 处理业务<br data-filtered="filtered">        .....<br data-filtered="filtered">        redisLock.unlock(); // 释放锁<br data-filtered="filtered">    } catch (Exception e) {<br data-filtered="filtered">        e.printStackTrace();<br data-filtered="filtered">    }<br data-filtered="filtered">}</div><ul class="pre-numbering" id="code_id_7" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li></ul></pre></div></div></div></div><p>❝有没有想过：一旦执行业务逻辑过程中抛出异常，程序就无法执行释放锁的流程。</p><p><strong>所以释放锁的代码一定要放在 </strong><strong>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​finally{}​</code>​ 块中。</strong></p><p>加锁的位置也有问题，放在 try 外面的话，如果执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​redisLock.lock()​</code>​ 加锁异常，但是实际指令已经发送到服务端并执行，只是客户端读取响应超时，就会导致没有机会执行解锁的代码。</p><p>所以 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​redisLock.lock()​</code>​ <strong>应该写在 try 代码块，这样保证一定会执行解锁逻辑。</strong></p><p>综上所述，正确代码位置如下 ：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_8" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">public void doSomething() {<br data-filtered="filtered">    try {<br data-filtered="filtered">        // 上锁<br data-filtered="filtered">        redisLock.lock();<br data-filtered="filtered">        // 处理业务<br data-filtered="filtered">        ...<br data-filtered="filtered">    } catch (Exception e) {<br data-filtered="filtered">        e.printStackTrace();<br data-filtered="filtered">    } finally {<br data-filtered="filtered">      // 释放锁<br data-filtered="filtered">      redisLock.unlock();<br data-filtered="filtered">    }<br data-filtered="filtered">}</div><ul class="pre-numbering" id="code_id_8" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li></ul></pre></div></div></div></div><h2 id="h10"><br data-filtered="filtered"></h2><h2 id="h11">实现可重入锁</h2><p>❝65 哥：可重入锁要如何实现呢？</p><p>当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的代码，可重入性就就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。</p><p>用一段代码解释可重入：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_9" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">public synchronized void a() {<br data-filtered="filtered">    b();<br data-filtered="filtered">}<br data-filtered="filtered">public synchronized void b() {<br data-filtered="filtered">    // pass<br data-filtered="filtered">}</div><ul class="pre-numbering" id="code_id_9" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li></ul></pre></div></div></div></div><p>假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时<strong>不可重入</strong>，线程就必须等待锁释放，再次争抢锁。</p><p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p><h2 id="h12">Redis Hash 可重入锁</h2><p>❝Redisson 类库就是通过 Redis Hash 来实现可重入锁</p><p>当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑。</p><p>退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。</p><p>可以看到可重入锁最大特性就是计数，计算加锁的次数。</p><p>所以当可重入锁需要在分布式环境实现时，我们也就需要统计加锁次数。</p><h3 id="h13">加锁逻辑</h3><p>❝我们可以使用 Redis hash 结构实现，key 表示被锁的共享资源， hash 结构的 fieldKey 的 value 则保存加锁的次数。</p><p><img src="https://s2.51cto.com/images/blog/202112/07002301_61ae38e59412152290.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 535px; height: 285px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_java_03"></p><p>通过 Lua 脚本实现原子性，假设 KEYS1 = 「lock」, ARGV「1000，uuid」：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_10" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">---- 1 代表 true<br data-filtered="filtered">---- 0 代表 false<br data-filtered="filtered">if (redis.call('exists', KEYS[1]) == 0) then<br data-filtered="filtered">    redis.call('hincrby', KEYS[1], ARGV[2], 1);<br data-filtered="filtered">    redis.call('pexpire', KEYS[1], ARGV[1]);<br data-filtered="filtered">    return 1;<br data-filtered="filtered">end ;<br data-filtered="filtered">if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then<br data-filtered="filtered">    redis.call('hincrby', KEYS[1], ARGV[2], 1);<br data-filtered="filtered">    redis.call('pexpire', KEYS[1], ARGV[1]);<br data-filtered="filtered">    return 1;<br data-filtered="filtered">end ;<br data-filtered="filtered">return 0;</div><ul class="pre-numbering" id="code_id_10" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li></ul></pre></div></div></div></div><p>加锁代码首先使用 Redis ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​exists​</code>​ 命令判断当前 lock 这个锁是否存在。</p><p>如果锁不存在的话，直接使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hincrby​</code>​​创建一个键为 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​lock​</code>​​ hash 表，并且为 Hash 表中键为 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​uuid​</code>​ 初始化为 0，然后再次加 1，最后再设置过期时间。</p><p>如果当前锁存在，则使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hexists​</code>​​判断当前 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​lock​</code>​​ 对应的 hash 表中是否存在 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​uuid​</code>​​ 这个键，如果存在，再次使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hincrby​</code>​ 加 1，最后再次设置过期时间。</p><p>最后如果上述两个逻辑都不符合，直接返回。</p><h3 id="h14">解锁逻辑</h3><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_11" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">-- 判断 hash set 可重入 key 的值是否等于 0<br data-filtered="filtered">-- 如果为 0 代表 该可重入 key 不存在<br data-filtered="filtered">if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then<br data-filtered="filtered">    return nil;<br data-filtered="filtered">end ;<br data-filtered="filtered">-- 计算当前可重入次数<br data-filtered="filtered">local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1);<br data-filtered="filtered">-- 小于等于 0 代表可以解锁<br data-filtered="filtered">if (counter &gt; 0) then<br data-filtered="filtered">    return 0;<br data-filtered="filtered">else<br data-filtered="filtered">    redis.call('del', KEYS[1]);<br data-filtered="filtered">    return 1;<br data-filtered="filtered">end ;<br data-filtered="filtered">return nil;</div><ul class="pre-numbering" id="code_id_11" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li><li>14.</li><li>15.</li></ul></pre></div></div></div></div><p>首先使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hexists​</code>​ 判断 Redis Hash 表是否存给定的域。</p><p>如果 lock 对应 Hash 表不存在，或者 Hash 表不存在 uuid 这个 key，直接返回 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​nil​</code>​。</p><p>若存在的情况下，代表当前锁被其持有，首先使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hincrby​</code>​​使可重入次数减 1 ，然后判断计算之后可重入次数，若小于等于 0，则使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​del​</code>​ 删除这把锁。</p><p>解锁代码执行方式与加锁类似，只不过解锁的执行结果返回类型使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Long​</code>​​。这里之所以没有跟加锁一样使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Boolean​</code>​ ,这是因为解锁 lua 脚本中，三个返回值含义如下：</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>1 代表解锁成功，锁被释放</li><li>0 代表可重入次数被减 1</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​null​</code>​ 代表其他线程尝试解锁，解锁失败.<ul><li><br data-filtered="filtered"></li></ul></li></ul><h2 id="h15"><br data-filtered="filtered"></h2><h2 id="h16">主从架构带来的问题</h2><p>❝到这里分布式锁「很完美了」吧，没想到分布式锁这么多门道。</p><p>路还很远，之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 主从模式导致的问题。</p><p>我们通常使用「Cluster 集群」或者「哨兵集群」的模式部署保证高可用。</p><p>这两个模式都是基于「主从架构数据同步复制」实现的数据同步，而 Redis 的主从复制默认是异步的。</p><p><br data-filtered="filtered"></p><p>我们试想下如下场景会发生什么问题：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>客户端 A 在 master 节点获取锁成功。</li><li>还没有把获取锁的信息同步到 slave 的时候，master 宕机。</li><li>slave 被选举为新 master，这时候没有客户端 A 获取锁的数据。</li><li>客户端 B 就能成功的获得客户端 A 持有的锁，违背了分布式锁定义的互斥。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p>虽然这个概率极低，但是我们必须得承认这个风险的存在。</p><p>❝Redis 的作者提出了一种解决方案，叫 Redlock（红锁）</p><p>Redis 的作者为了统一分布式锁的标准，搞了一个 Redlock，算是 Redis 官方对于实现分布式锁的指导规范，https://redis.io/topics/distlock，但是这个 Redlock 也被国外的一些分布式专家给喷了。</p><p>因为它也不完美，有“漏洞”。</p><h2 id="h17"><br data-filtered="filtered"></h2><h2 id="h18">什么是 Redlock</h2><p>红锁是不是这个？</p><p><img src="https://s2.51cto.com/images/blog/202112/07002301_61ae38e5b20c178468.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 603px; height: 626px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_分布式_04"></p><p>泡面吃多了你，​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redlock​</code>​ 红锁是为了解决主从架构中当出现主从切换导致多个客户端持有同一个锁而提出的一种算法。</p><p><br data-filtered="filtered"></p><p>想用使用 Redlock，官方建议在不同机器上部署 5 个 Redis 主节点，节点都是完全独立，也不使用主从复制，使用多个节点是为容错。</p><p><strong>一个客户端要获取锁有 5 个步骤</strong>：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>客户端获取当前时间 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​T1​</code>​（毫秒级别）；</li><li>使用相同的 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​和 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​value​</code>​顺序尝试从 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​N​</code>​个 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redis​</code>​实例上获取锁。<ol><li><br data-filtered="filtered"></li></ol></li></ol><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>每个请求都设置一个超时时间（毫秒级别），该超时时间要远小于锁的有效时间，这样便于快速尝试与下一个实例发送请求。</li><li>比如锁的自动释放时间 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​10s​</code>​，则请求的超时时间可以设置 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​5~50​</code>​ 毫秒内，这样可以防止客户端长时间阻塞。<ul><li><br data-filtered="filtered"></li></ul></li></ul><p>客户端获取当前时间 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​T2​</code>​​ 并减去步骤 1 的 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​T1​</code>​​ 来计算出获取锁所用的时间（​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​T3 = T2 -T1​</code>​）。<strong>当且仅当客户端在大多数实例（</strong><strong>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​N/2 + 1​</code>​）获取成功，且获取锁所用的总时间 T3 小于锁的有效时间，才认为加锁成功，否则加锁失败。</strong></p><p>如果第 3 步加锁成功，则执行业务逻辑操作共享资源，<strong>key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</strong></p><p>如果因为某些原因，获取锁失败（没有在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），<strong>客户端应该在所有的 Redis 实例上进行解锁</strong>（即便某些 Redis 实例根本就没有加锁成功）。</p><p><strong>另外部署实例的数量要求是奇数，为了能很好的满足过半原则，如果是 6 台则需要 4 台获取锁成功才能认为成功，所以奇数更合理</strong></p><p>❝事情可没这么简单，Redis 作者把这个方案提出后，受到了业界著名的分布式系统专家的<strong>质疑</strong>。</p><p>两人好比神仙打架，两人一来一回论据充足的对一个问题提出很多论断……</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li><br data-filtered="filtered"><ul><li><br data-filtered="filtered"></li></ul></li></ul><h2 id="h19">Redlock 是与非</h2><p>Martin Kleppmann 认为锁定的目的是为了保护对共享资源的读写，而分布式锁应该「高效」和「正确」。</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>高效性：分布式锁应该要满足高效的性能，Redlock 算法向 5 个节点执行获取锁的逻辑性能不高，成本增加，复杂度也高；</li><li>正确性：分布式锁应该防止并发进程在同一时刻只能有一个线程能对共享数据读写。<ul><li><br data-filtered="filtered"></li></ul></li></ul><p>出于这两点，我们没必要承担 Redlock 的成本和复杂，运行 5 个 Redis 实例并判断加锁是否满足大多数才算成功。</p><p>主从架构崩溃恢复极小可能发生，这没什么大不了的。使用单机版就够了，Redlock 太重了，没必要。</p><p><strong>Martin</strong> 认为 <strong>Redlock</strong> 根本达不到安全性的要求，也依旧存在锁失效的问题！</p><h3 id="h20">Martin 的结论</h3><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li><strong>Redlock</strong> 不伦不类：对于偏好效率来讲，<strong>Redlock</strong> 比较重，没必要这么做，而对于偏好正确性来说，<strong>Redlock</strong> 是不够安全的。</li><li>时钟假设不合理：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</li><li>无法保证正确性：<strong>Redlock</strong> 不能提供类似 <strong>fencing token</strong> 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 <strong>Zookeeper</strong>。<ol><li><br></li></ol></li></ol><h2 id="h21">Redis 作者 Antirez 的反驳</h2><p>在 <strong>Redis</strong> 作者的反驳文章中，有 3 个重点：</p><ul><li><ul><li><br></li></ul></li><li>时钟问题：<strong>Redlock</strong> 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」，只要误差不要超过锁的租期即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</li><li>网络延迟、进程暂停问题：</li><li><ul><li><ul><li><br></li></ul></li><li>客户端在拿到锁之前，无论经历什么耗时长问题，<strong>Redlock</strong> 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 <strong>NPC</strong>，那 <strong>Redlock、Zookeeper</strong> 都无能为力<ul><li><br></li></ul></li></ul></li><li>质疑 fencing token 机制。<ul><li><br></li></ul></li></ul><p>关于 Redlock 的争论我们下期再见，现在进入 Redisson 实现分布式锁实战部分。</p><h2 id="h22"><br></h2><h2 id="h23">Redisson 分布式锁</h2><p>基于 SpringBoot starter 方式，添加 starter。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_12" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&lt;dependency&gt;<br>  &lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>  &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;<br>  &lt;version&gt;3.16.4&lt;/version&gt;<br>&lt;/dependency&gt;</div><ul class="pre-numbering" id="code_id_12" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li></ul></pre></div></div></div></div><p>不过这里需要注意 springboot 与 redisson 的版本，因为官方推荐 redisson 版本与 springboot 版本配合使用。</p><p>将 Redisson 与 Spring Boot 库集成，还取决于 Spring Data Redis 模块。</p><p>使用 SpringBoot 2.5.x 版本， 所以需要添加 redisson-spring-data-25。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_13" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&lt;dependency&gt;<br>  &lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>  &lt;!-- for Spring Data Redis v.2.5.x --&gt;<br>  &lt;artifactId&gt;redisson-spring-data-25&lt;/artifactId&gt;<br>  &lt;version&gt;3.16.4&lt;/version&gt;<br>&lt;/dependency&gt;</div><ul class="pre-numbering" id="code_id_13" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li></ul></pre></div></div></div></div><p>添加配置文件</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_14" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">spring:<br>  redis:<br>    database:<br>    host:<br>    port:<br>    password:<br>    ssl:<br>    timeout:<br>    # 根据实际情况配置 cluster 或者哨兵<br>    cluster:<br>      nodes:<br>    sentinel:<br>      master:<br>      nodes:</div><ul class="pre-numbering" id="code_id_14" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li><li>14.</li></ul></pre></div></div></div></div><p>就这样在 Spring 容器中我们拥有以下几个 Bean 可以使用:</p><ul><li><ul><li><br></li></ul></li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​RedissonClient​</code>​</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​RedissonRxClient​</code>​</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​RedissonReactiveClient​</code>​</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​RedisTemplate​</code>​</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​ReactiveRedisTemplate​</code>​<ul><li><br></li></ul></li></ul><h2 id="h24">失败无限重试</h2><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_15" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">RLock lock = redisson.getLock("AAA");<br>try {<br><br>  // 1.最常用的第一种写法<br>  lock.lock();<br><br>  // 执行业务逻辑<br>  .....<br><br>} finally {<br>  lock.unlock();<br>}</div><ul class="pre-numbering" id="code_id_15" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li></ul></pre></div></div></div></div><p>拿锁失败时会不停的重试，具有 Watch Dog 自动延期机制，默认续 30s 每隔 30/3=10 秒续到 30s。</p><h2 id="h25">失败超时重试，自动续命</h2><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_16" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 尝试拿锁10s后停止重试,获取失败返回false，具有Watch Dog 自动延期机制， 默认续30s<br>boolean flag = lock.tryLock(10, TimeUnit.SECONDS);</div><ul class="pre-numbering" id="code_id_16" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><h2 id="h26">超时自动释放锁</h2><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_17" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 没有Watch Dog ，10s后自动释放,不需要调用 unlock 释放锁。<br>lock.lock(10, TimeUnit.SECONDS);</div><ul class="pre-numbering" id="code_id_17" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><h2 id="h27">超时重试，自动解锁</h2><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_18" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁,没有 Watch dog<br>boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);<br>if (res) {<br>   try {<br>     ...<br>   } finally {<br>       lock.unlock();<br>   }<br>}</div><ul class="pre-numbering" id="code_id_18" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li></ul></pre></div></div></div></div><h2 id="h28">Watch Dog 自动延时</h2><p>如果获取分布式锁的节点宕机，且这个锁还处于锁定状态，就会出现死锁。</p><p>为了避免这个情况，我们都会给锁设置一个超时自动释放时间。</p><p>然而，还是会存在一个问题。</p><p>假设线程获取锁成功，并设置了 30 s 超时，但是在 30s 内任务还没执行完，锁超时释放了，就会导致其他线程获取不该获取的锁。</p><p>所以，Redisson 提供了 watch dog 自动延时机制，提供了一个监控锁的看门狗，它的作用是在 Redisson 实例被关闭前，不断的延长锁的有效期。</p><p>也就是说，如果一个拿到锁的线程一直没有完成逻辑，那么看门狗会帮助线程不断的延长锁超时时间，锁不会因为超时而被释放。</p><p>默认情况下，看门狗的续期时间是 30s，也可以通过修改 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Config.lockWatchdogTimeout​</code>​ 来另行指定。</p><p>另外 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redisson​</code>​​ 还提供了可以指定 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​leaseTime​</code>​ 参数的加锁方法来指定加锁的时间。</p><p>超过这个时间后锁便自动解开了，不会延长锁的有效期。</p><p>原理如下图：</p><p><img src="https://s2.51cto.com/images/blog/202112/07002302_61ae38e61dcac76212.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 100%; height: 734px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_多线程_05"></p><p><strong>有两个点需要注意：</strong></p><ul><li><ul><li><br></li></ul></li><li><strong>watchDog 只有在未显示指定加锁超时时间（leaseTime）时才会生效。</strong></li><li><strong>lockWatchdogTimeout 设定的时间不要太小 ，比如设置的是 100 毫秒，由于网络直接导致加锁完后，watchdog 去延期时，这个 key 在 redis 中已经被删除了。</strong><ul><li><br></li></ul></li></ul><h2 id="h29">源码导读</h2><p>在调用 lock 方法时，会最终调用到 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​tryAcquireAsync​</code>​。</p><p>调用链为：​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​lock()-&gt;tryAcquire-&gt;tryAcquireAsync​</code>​，详细解释如下：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_19" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {<br>        RFuture&lt;Long&gt; ttlRemainingFuture;<br>        //如果指定了加锁时间，会直接去加锁<br>        if (leaseTime != -1) {<br>            ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>        } else {<br>            //没有指定加锁时间 会先进行加锁，并且默认时间就是 LockWatchdogTimeout的时间<br>            //这个是异步操作 返回RFuture 类似netty中的future<br>            ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,<br>                    TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<br>        }<br><br>        //这里也是类似netty Future 的addListener，在future内容执行完成后执行<br>        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; {<br>            if (e != null) {<br>                return;<br>            }<br><br>            // lock acquired<br>            if (ttlRemaining == null) {<br>                // leaseTime不为-1时，不会自动延期<br>                if (leaseTime != -1) {<br>                    internalLockLeaseTime = unit.toMillis(leaseTime);<br>                } else {<br>                    //这里是定时执行 当前锁自动延期的动作,leaseTime为-1时，才会自动延期<br>                    scheduleExpirationRenewal(threadId);<br>                }<br>            }<br>        });<br>        return ttlRemainingFuture;<br>    }</div><ul class="pre-numbering" id="code_id_19" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li><li>14.</li><li>15.</li><li>16.</li><li>17.</li><li>18.</li><li>19.</li><li>20.</li><li>21.</li><li>22.</li><li>23.</li><li>24.</li><li>25.</li><li>26.</li><li>27.</li><li>28.</li><li>29.</li><li>30.</li><li>31.</li></ul></pre></div></div></div></div><p>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​scheduleExpirationRenewal​</code>​​ 中会调用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​renewExpiration​</code>​​ 启用了一个 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​timeout​</code>​ 定时，去执行延期动作。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_20" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">private void renewExpiration() {<br>        ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>        if (ee == null) {<br>            return;<br>        }<br><br>        Timeout task = commandExecutor.getConnectionManager()<br>          .newTimeout(new TimerTask() {<br>            @Override<br>            public void run(Timeout timeout) throws Exception {<br>                // 省略部分代码<br>                ....<br><br>                RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);<br>                future.onComplete((res, e) -&gt; {<br>                    ....<br><br>                    if (res) {<br>                        //如果 没有报错，就再次定时延期<br>                        // reschedule itself<br>                        renewExpiration();<br>                    } else {<br>                        cancelExpirationRenewal(null);<br>                    }<br>                });<br>            }<br>            // 这里我们可以看到定时任务 是 lockWatchdogTimeout 的1/3时间去执行 renewExpirationAsync<br>        }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);<br><br>        ee.setTimeout(task);<br>    }</div><ul class="pre-numbering" id="code_id_20" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li><li>14.</li><li>15.</li><li>16.</li><li>17.</li><li>18.</li><li>19.</li><li>20.</li><li>21.</li><li>22.</li><li>23.</li><li>24.</li><li>25.</li><li>26.</li><li>27.</li><li>28.</li><li>29.</li><li>30.</li><li>31.</li></ul></pre></div></div></div></div><p>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​scheduleExpirationRenewal​</code>​​ 会调用到 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​renewExpirationAsync​</code>​，执行下面这段 lua 脚本。</p><p>他主要判断就是 这个锁是否在 redis 中存在，如果存在就进行 pexpire 延期。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_21" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">protected RFuture&lt;Boolean&gt; renewExpirationAsync(long threadId) {<br>        return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,<br>                "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +<br>                        "redis.call('pexpire', KEYS[1], ARGV[1]); " +<br>                        "return 1; " +<br>                        "end; " +<br>                        "return 0;",<br>                Collections.singletonList(getRawName()),<br>                internalLockLeaseTime, getLockName(threadId));<br>    }</div><ul class="pre-numbering" id="code_id_21" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li></ul></pre></div></div></div></div><ul><li><ul><li><br></li></ul></li><li>watch dog 在当前节点还存活且任务未完成则每 10 s 给锁续期 30s。</li><li>程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中；</li><li>要使 watchLog 机制生效 ，lock 时 不要设置 过期时间。</li><li>watchlog 的延时时间 可以由 lockWatchdogTimeout 指定默认延时时间，但是不要设置太小。</li><li>watchdog 会每 lockWatchdogTimeout/3 时间，去延时。</li><li>通过 lua 脚本实现延迟。<ul><li><br></li></ul></li></ul><h2 id="h30">、</h2><p><br></p></div></div>
                    </div>

                    <div id="asideoffset"></div>
                    <div class="clearfix label-list">

                        <!--            <span>本文包含：</span>-->
                        <!--          -->
                        <!--            <a href="" target="_blank"></a>-->

                    </div>
                </div>
                <div class="action-box">
                    <ul>
                        <li>
                            <strong class="is-praise  " type="1" blog_id="4761555" userid="13616762">
                                <a href="javascript:;"><i></i></a>
                                <span><b class="praise-num"></b>赞</span>
                            </strong>
                        </li>
                        <li>
                            <strong class="favorites-opt">
                                <a href="javascript:;"><i></i></a>
                                <span><b class="favorites-num"></b>收藏</span>
                            </strong>
                        </li>
                        <li>
                            <strong class="Topraise">
                                <a href="javascript:;"><i class="iconblog blogpinglun"></i></a>
                                <span><b class="comments_num"></b>评论</span>
                            </strong>
                        </li>
                        <li class="share">
                            <strong class="">
                                <a href="javascript:;"><i class="iconblog blogfen"></i></a>
                                <span>分享</span>
                            </strong>
                        </li>
                        <li>
                            <strong class="article-report">
                                <a href="javascript:;"><i class="iconblog blogjubaobeifen report-icon" style="font-size: 23px"></i></a>
                                <span>举报</span>
                            </strong>
                        </li>
                    </ul>
                </div>
                <div class="clearfix lists">
                    <p class="fl"><span>上一篇：</span><a href="https://blog.51cto.com/u_13626762/4761534">程序员敲诈老板，或面临 37 年监禁</a></p>
                    <p class="fr"><span>下一篇：</span><a href="https://blog.51cto.com/u_13626762/4761600">我的十年程序员生涯</a></p>
                </div>
                <div class="text-aticle">

                </div>
            </div>


            <div class="common-section common-spacing mb30 comment-box" id="comment">
                <div class="comment-textarea clearfix">
                    <div class="avatar">
                        <a href="https://blog.51cto.com/" class="header-img" target="_blank">
                            <img src="https://ucenter.51cto.com/images/noavatar_middle.gif">
                        </a>
                    </div>
                    <div class="textarea-box">
                        <div class="textarea-show clearfix">
                            <span>提问和评论都可以，用心的回复会被更多人看到</span>
                            <strong>评论</strong>
                        </div>
                        <div class="textarea-hide">
                            <div class="top">
                                <textarea class="textareadiv textareadiv-publish" name="" id="textareadiv-publish" placeholder="提问和评论都可以，用心的回复会被更多人看到和认可" maxlength="500"></textarea>
                            </div>
                            <div class="bot clearfix">
                                <strong class="fr publish-btn" flag="1" id="publish-btn">发布评论</strong>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="comment-num" style="display:none;">
                    <strong>全部评论</strong>
                    <span>(<b id="CommentNum"></b>)</span>
                    <span class="fr sort" type="up_num" order="0"><i class="iconblog blogzuire"></i>最热</span>
                    <span class="fr sort on" type="create_time" order="0"><i class="iconblog blogzuixinblogzuixin"></i>最新</span>
                </div>
                <div class="comment-List-box"></div>
            </div>

            <section class="common-section common-spacing mb30">
                <div class="clearfix common-sub-title">
                    <strong>相关文章</strong>
                </div>
                <ul class="recommend-about">
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_12099683/3689370" data-report-query="xiangguantuijian&amp;01" target="_blank" class="title">
                                <div class="tit">redis分布式锁redisson实现原理</div>
                                <p> 一致性，但是具备高可用，性能高zookeeper：使用的是CP，强一致性和分区容错性。只有当zookeeper集群半数以上的节点数据同步ok了，才返回给客户端成功，redis是只要master成...</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         zookeeper                                    </span>
                                <span class="tag-item">
                                         高可用                                    </span>
                                <span class="tag-item">
                                         分布式锁                                    </span>
                                <span class="tag-item">
                                         强一致性                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_15061948/4343153" data-report-query="xiangguantuijian&amp;02" target="_blank" class="title">
                                <div class="tit">Redis分布式锁的正确实现方式</div>
                                <p> Redis分布式锁的正确实现方式 前言 分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题 ...</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         客户端                                    </span>
                                <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         加锁                                    </span>
                                <span class="tag-item">
                                         分布式锁                                    </span>
                                <span class="tag-item">
                                         lua                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_15912066/5936248" data-report-query="xiangguantuijian&amp;03" target="_blank" class="title">
                                <div class="tit">redis分布式锁 Redisson的原理</div>
                                <p> 第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         Redisson                                    </span>
                                <span class="tag-item">
                                         加锁                                    </span>
                                <span class="tag-item">
                                         客户端                                    </span>
                                <span class="tag-item">
                                         redis                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_12004792/3140271" data-report-query="xiangguantuijian&amp;04" target="_blank" class="title">
                                <div class="tit">Redis(十三):Redis分布式锁的正确实现方式</div>
                                <p> 前言 分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         分布式                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_12902932/1924602" data-report-query="xiangguantuijian&amp;05" target="_blank" class="title">
                                <div class="tit">redisson实现分布式锁原理</div>
                                <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redisson分布式锁之前的基于注解的锁有一种锁是基本redis的分布式锁，锁的实现我是基于redisson组件提供的RLock，这篇来看看redisson是如何实现锁的。不同版本实现锁的机制并不相同引用的redisson最近发布的版本3.2.3，不同的版本可能实现锁的机制并不相同，早期版本好像是采用</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         接口                                    </span>
                                <span class="tag-item">
                                         如何                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_15127691/4371758" data-report-query="xiangguantuijian&amp;06" target="_blank" class="title">
                                <div class="tit">Redis实战-Redisson-分布式锁</div>
                                <p> 1. 简介 随着技术的快速发展，业务系统规模的不断扩大，分布式系统越来越普及。一个应用往往会部署到多台机器上，在一些业务场景中，为了保证数据的一致性，要求在同一时刻，同一任务只在一个节点上运行，保证同一个方法同一时刻只能被一个线程执行。这时候分布式锁就运用而生了。 分布式锁有很多的解决方案。常见的有 ...</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         SpringBoot                                    </span>
                                <span class="tag-item">
                                         Redis                                    </span>
                                <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         测试方法                                    </span>
                                <span class="tag-item">
                                         spring                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_11579569/5522147" data-report-query="xiangguantuijian&amp;07" target="_blank" class="title">
                                <div class="tit">【分布式缓存Redis】Redisson原理与实战</div>
                                <p> :18P165 165、 缓存-分布式锁Red</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redission                                    </span>
                                <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         分布式锁                                    </span>
                                <span class="tag-item">
                                         缓存                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_15912066/6084951" data-report-query="xiangguantuijian&amp;08" target="_blank" class="title">
                                <div class="tit">Redisson分布式锁的实现原理</div>
                                <p> 一、写在前面现在面试，一般都会聊聊分布式系统这块的东西。通常面试官都会从服务框架（Spring Cloud、Dubbo）聊起，一路聊到分布式事务、分布式锁、ZooKeeper等知识。所以咱们这篇文章就来聊聊分布式锁这块知识，具体的来看看Redis分布式锁的实现原理。说实话，如果在公司里落地生产环境用分布式锁的时候，一定是会用开源类库的，比如Redis分布式锁，一般就是用Redisson框架就好了，</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redisson                                    </span>
                                <span class="tag-item">
                                         redission原理                                    </span>
                                <span class="tag-item">
                                         redisson分布式锁                                    </span>
                                <span class="tag-item">
                                         Powered by 金山文档                                    </span>
                                <span class="tag-item">
                                         加锁                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_11579569/5948504" data-report-query="xiangguantuijian&amp;09" target="_blank" class="title">
                                <div class="tit">【分布式锁】Redis和Redisson原理与应用</div>
                                <p> 一、参考资料​​EhCache - 简书​​​​阿里云Redis开发规范-阿里云开发者社区​​</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         redisson                                    </span>
                                <span class="tag-item">
                                         分布式锁                                    </span>
                                <span class="tag-item">
                                         Redis                                    </span>
                                <span class="tag-item">
                                         缓存                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/zhangxueliang/3000235" data-report-query="xiangguantuijian&amp;10" target="_blank" class="title">
                                <div class="tit">Redisson实现分布式锁原理及代码实战</div>
                                <p> Redission分布式锁原理实现Redis的分布式锁，除了自己基于redis client原生api来实现之外，还可以使用开源框架：RedissionRedisson是一个企业级的开源Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？回想一下上面说的，如果自己写代码来通过redis设置一个值，是通过下面这个命令设置的。SET anyLock unique...</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redis                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_13672582/2320328" data-report-query="" target="_blank" class="title">
                                <div class="tit">Redis分布式锁的正确实现方式（Java版）</div>
                                <p> 前言分布式锁一般有三种实现方式：1.数据库乐观锁；2.基于Redis的分布式锁；3.基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。可靠性首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         JAVA                                    </span>
                            </div>
                        </div>

                    </li>
                </ul>
            </section>

        </article>

        <aside class="detail-content-right">
            <!--右上角统计-->
            <section class="common-section common-spacing mb24 user-intr" style="visibility: hidden;">
                <div class="user-content">
                    <div class="top">
                        <div class="avatar">
                            <div class="avatar-img">
                                <a href="https://blog.51cto.com/u_13626762" target="_blank" rel="nofollow">
                                    <img class="is-vip-img is-vip-img-4" data-uid="13616762" src="https://s2.51cto.com/oss/201904/09/9210cdc5924b0d7be8b3599dc11eb6be.jpg?x-oss-process=image/format,webp/ignore-error,1">
                                </a>
                            </div>
                        </div>
                        <div class="clearfix username">
                            <a href="https://blog.51cto.com/u_13626762" target="_blank"><span class="blog-user" title="Hollis在51CTO" style="max-width: 272px;">Hollis在51CTO</span></a>
                            <div class="icon">
                                <ul class="clearfix detail-list"></ul>
                            </div>
                        </div>
                    </div>
                    <div class="identify-list"></div>
                    <div class="bottom" id="userStat"><div class="num-name num-top">
                        <ul class="first-num">
                            <li>
                                <div class="num"><a href="https://blog.51cto.com/u_13626762/original" target="_blank" rel="nofollow">611</a></div>
                                <div class="label-name"><a href="https://blog.51cto.com/u_13626762/original" target="_blank" rel="nofollow">原创</a></div>
                            </li>
                            <li>
                                <div class="num">108.1<span>万</span></div>
                                <div class="label-name">人气</div>
                            </li>
                            <li>
                                <div class="num"><a href="https://blog.51cto.com/u_13626762/followers" target="_blank" rel="nofollow">43<span></span></a></div>
                                <div class="label-name"><a href="https://blog.51cto.com/u_13626762/followers" target="_blank" rel="nofollow">粉丝</a></div>
                            </li>
                            <li>
                                <div class="num">4<span></span></div>
                                <div class="label-name">评论</div>
                            </li>
                        </ul>
                    </div>
                        <div class="lines"></div>
                        <div class="num-name num-bottom">
                            <ul>
                                <li>
                                    <div class="num"><a href="https://blog.51cto.com/u_13626762/translate" target="_blank" rel="nofollow">0</a></div>
                                    <div class="label-name"><a href="https://blog.51cto.com/u_13626762/translate" target="_blank" rel="nofollow">翻译</a></div>
                                </li>
                                <li>
                                    <div class="num"><a href="https://blog.51cto.com/u_13626762/reproduce" target="_blank" rel="nofollow">2947</a></div>
                                    <div class="label-name"><a href="https://blog.51cto.com/u_13626762/reproduce" target="_blank" rel="nofollow">转载</a></div>
                                </li>
                                <li>
                                    <div class="num"><a href="https://blog.51cto.com/u_13626762/following" target="_blank" rel="nofollow">1</a></div>
                                    <div class="label-name"><a href="https://blog.51cto.com/u_13626762/following" target="_blank" rel="nofollow">关注</a></div>
                                </li>
                                <li>
                                    <div class="num">26</div>
                                    <div class="label-name">收藏</div>
                                </li>
                                <div class="clear"></div>
                            </ul>
                        </div></div>
                    <div id="medalListBox" class="medal-list"><div title="知名人士" class="medalItem item"><img src="https://s2.51cto.com/images/202203/15ab11299b3053d6c281582e1acf449c18b312.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="一眼万年" class="medalItem item"><img src="https://s2.51cto.com/images/202203/195f76d50ffb2cd8b16664147e48ea8edd9fd6.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="锋芒毕露" class="medalItem item"><img src="https://s2.51cto.com/images/202203/f6f53e943b8feeab330770a0ec42efed855946.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="崭露头角" class="medalItem item"><img src="https://s2.51cto.com/images/202203/31b28da6607cbc93cd900122f89b19420ac8c5.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="自成一派" class="medalItem item"><img src="https://s2.51cto.com/images/202203/81ba9de79b69d05f4333211abd2d0d4a008a05.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="一代宗师" class="medalItem item"><img src="https://s2.51cto.com/images/202202/61ba4e730b80264ca0076678a0dbd3e16f64bb.png?&amp;x-oss-process=image/format,webp"></div><div title="炉火纯青" class="medalItem item"><img src="https://s2.51cto.com/images/202202/c1c0bc692d7397c63280391ec9fc97b029aa51.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="博闻强识" class="medalItem item"><img src="https://s2.51cto.com/images/202202/a8ef82362559226c848000f191ce5a08f03207.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="持之以恒" class="medalItem item"><img src="https://s2.51cto.com/images/202202/b67592a476d24a33731174926f050c7209f5df.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="挑战自我" class="medalItem item"><img src="https://s2.51cto.com/images/202202/03ea5c8040c00c2cbaf04751aae5540380427a.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div></div>
                    <div class="operating clearfix ">
                        <a id="checkFollow2_13616762" class="follow-1 checkFollow on" rel="nofollow">关注</a>
                        <button class="sx" data="https://home.51cto.com/space?uid=13616762" id="ToSx"><a href="javascript:;" rel="nofollow"><i class="iconblog blogsixin"></i>私信</a></button>
                    </div>
                </div>
            </section>

            <!-- 分类列表 -->
            <!-- 近期文章 -->
            <section class="common-section common-spacing mb24" style="visibility: hidden;">
                <div class="clearfix common-sub-title">
                    <strong title="近期文章">近期文章</strong>
                </div>
                <ul class="common-list">
                    <li>
                        <a href="https://blog.51cto.com/u_15618380/6168766" target="_blank" title="屏幕录制软件有哪些？屏幕录制软件分享！​">1.屏幕录制软件有哪些？屏幕录制软件分享！​</a>
                    </li>
                    <li>
                        <a href="https://blog.51cto.com/u_15905566/6168643" target="_blank" title="鹏业软件为中国电子系统工程第三建设有限公司开展企业定制培训">2.鹏业软件为中国电子系统工程第三建设有限公司开展企业定制培训</a>
                    </li>
                    <li>
                        <a href="https://blog.51cto.com/u_15994668/6168674" target="_blank" title="倒计时，4.21日第15届CBE中国电池展，台湾高技与您展会见！">3.倒计时，4.21日第15届CBE中国电池展，台湾高技与您展会见！</a>
                    </li>
                    <li>
                        <a href="https://blog.51cto.com/u_14291117/6168648" target="_blank" title="JavaScript 引擎 V8 执行流程概述">4.JavaScript 引擎 V8 执行流程概述</a>
                    </li>
                    <li>
                        <a href="https://blog.51cto.com/u_15953612/6168758" target="_blank" title="MySQL基础（一）：SQL语句">5.MySQL基础（一）：SQL语句</a>
                    </li>
                </ul>
            </section>
            <section class="common-fix fix-table">
                <!-- 新人活动 -->
                <a class="ac-box mb24" href="https://blog.51cto.com/51ctoblog/5841499#xiang" target="_blank"><img alt="新人福利" src="https://s2.51cto.com/blog/activity/bride/DetailsBride.gif?x-oss-process=image/ignore-error,1"></a>
                <!-- 文章目录 -->
                <div class="common-section common-spacing table-contents common-content-directory">
                    <div class="clearfix common-sub-title">
                        <strong title="文章目录">文章目录</strong>
                    </div>
                    <div class="directory" id="directory-parent1">
                        <ul class="directory-list" id="directory-right">
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h1">
                                                                                分布式锁入门                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h3">
                                                                                超时设置                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h5">
                                                                                释放了不是自己加的锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h7">
                                                                                正确设置锁超时                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h9">
                                                                                加解锁代码位置有讲究                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h11">
                                                                                实现可重入锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h12">
                                                                                Redis Hash 可重入锁                                    </span>
                                </div>
                            </li>
                            <li class="lv3">
                                <div class="title">
                                    <span data-id="#h13">
                                                                                加锁逻辑                                    </span>
                                </div>
                            </li>
                            <li class="lv3">
                                <div class="title">
                                    <span data-id="#h14">
                                                                                解锁逻辑                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h16">
                                                                                主从架构带来的问题                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h18">
                                                                                什么是 Redlock                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h19">
                                                                                Redlock 是与非                                    </span>
                                </div>
                            </li>
                            <li class="lv3">
                                <div class="title">
                                    <span data-id="#h20">
                                                                                Martin 的结论                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h21">
                                                                                Redis 作者 Antirez 的反驳                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h23">
                                                                                Redisson 分布式锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h24">
                                                                                失败无限重试                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h25">
                                                                                失败超时重试，自动续命                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h26">
                                                                                超时自动释放锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h27">
                                                                                超时重试，自动解锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h28">
                                                                                Watch Dog 自动延时                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h29">
                                                                                源码导读                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h30">
                                                                                、                                    </span>
                                </div>
                            </li>
                            <div class="arrow on" style="top: 596.45px;"></div></ul>
                    </div>
                    <div class="table-contents"></div>
                </div>
            </section>



        </aside>
    </div>
    <!--悬浮小菜单-->
    <aside class="minmenu" style="display: block;">
        <ul>
            <li class="signIn" signid="2">
                <button id="signIn">  每日签到</button>
            </li>
            <li class="editArticle" editid="2">
                <div class="new_bloger ">新人福利</div>
                <button id="editArticle"><i class="iconblog blogxiewz"></i></button>
            </li>
            <li class="scrollToTop">
                <i class="iconblog bloggengduo1"></i>
            </li>
        </ul>
    </aside>
</div><div class="Content detail-content-new">
    <!--关注-->
    <div class="fixtitle" style="display: none;">
        <div class="clearfix Page">
            <h3 class="fl title">Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结</h3>
            <div class="messbox fr">
                <a id="checkFollow1_13616762" class="follow-1 checkFollow on">关注</a>
                <a href="https://blog.51cto.com/u_13626762" class="name" target="_blank" title="Hollis在51CTO">Hollis在51CTO</a>
                <strong>
                    <a href="https://blog.51cto.com/u_13626762" class="avatar" target="_blank">
                        <img class="is-vip-img is-vip-img-4" data-uid="13616762" src="https://s2.51cto.com/oss/201904/09/9210cdc5924b0d7be8b3599dc11eb6be.jpg?x-oss-process=image/format,webp/ignore-error,1">
                    </a>
                </strong>
            </div>
        </div>
    </div>
    <!--大模块引入-->
    <div class="clearfix Page" id="page_center" style="position:relative;">
        <aside class="detail-content-directory common-content-directory">
            <!-- 文章目录 -->
            <section class="common-section common-spacing table-contents" style="background:none">
                <div class="clearfix common-sub-title">
                    <strong title="文章目录">文章目录</strong>
                    <i class="iconblog blogquxiao18" id="closeDirectory"></i>
                </div>
                <div class="directory" id="directory-parent2">
                    <ul class="directory-list directory-list-left" id="directory-left">
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h1">
                                                                        分布式锁入门                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h3">
                                                                        超时设置                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h5">
                                                                        释放了不是自己加的锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h7">
                                                                        正确设置锁超时                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h9">
                                                                        加解锁代码位置有讲究                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h11">
                                                                        实现可重入锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h12">
                                                                        Redis Hash 可重入锁                                </span>
                            </div>
                        </li>
                        <li class="lv3">
                            <div class="title">
                                <span data-id="#h13">
                                                                        加锁逻辑                                </span>
                            </div>
                        </li>
                        <li class="lv3">
                            <div class="title">
                                <span data-id="#h14">
                                                                        解锁逻辑                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h16">
                                                                        主从架构带来的问题                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h18">
                                                                        什么是 Redlock                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h19">
                                                                        Redlock 是与非                                </span>
                            </div>
                        </li>
                        <li class="lv3">
                            <div class="title">
                                <span data-id="#h20">
                                                                        Martin 的结论                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h21">
                                                                        Redis 作者 Antirez 的反驳                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h23">
                                                                        Redisson 分布式锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h24">
                                                                        失败无限重试                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h25">
                                                                        失败超时重试，自动续命                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h26">
                                                                        超时自动释放锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h27">
                                                                        超时重试，自动解锁                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h28">
                                                                        Watch Dog 自动延时                                </span>
                            </div>
                        </li>
                        <li class="lv1">
                            <div class="title">
                                <span data-id="#h29">
                                                                        源码导读                                </span>
                            </div>
                        </li>
                        <li class="lv1 on">
                            <div class="title">
                                <span data-id="#h30">
                                                                        、                                </span>
                            </div>
                        </li>
                    </ul>
                </div>
            </section>
        </aside>
        <article class="detail-content-left">
            <div class="common-section common-spacing mb30 article-detail">
                <div class="title">
                    <h1>Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结</h1>
                    <span class="reprint">转载</span>
                </div>
                <div class="messbox">
                    <p class="clearfix mess-line1">
                        <a class="fl" href="https://blog.51cto.com/u_13626762" rel="nofollow">Hollis在51CTO</a>
                        <time class="fl" pubdate="2021-12-07 17:05:11">2021-12-07 17:05:11</time>
                    </p>
                    <p class="clearfix mess-tag">
                        <strong class="fl">
                            <em class="fl">文章标签</em>
                            <a href="https://blog.51cto.com/topic/fenbushi.html" class="fl  shence_tag" target="_blank">分布式</a>
                            <a href="https://blog.51cto.com/topic/redis.html" class="fl  shence_tag" target="_blank">redis</a>
                            <a href="https://blog.51cto.com/topic/java.html" class="fl  shence_tag" target="_blank">java</a>
                            <a href="https://blog.51cto.com/topic/the-database-1.html" class="fl  shence_tag" target="_blank">数据库</a>
                            <a href="https://blog.51cto.com/topic/multithreading.html" class="fl  shence_tag" target="_blank">多线程</a>
                        </strong>
                        <strong class="fl">
                            <em class="fl">文章分类</em>
                            <a href="https://blog.51cto.com/nav/ops" class="fl shence_cate" target="_blank" rel="nofollow">运维</a>
                        </strong>
                        <strong class="fl"><em class="fl">阅读数</em><b class="fl">21</b></strong></p>
                </div>
                <div class="article-content-wrap">
                    <div class="artical-content-bak main-content editor-side-new">
                        <div class="con editor-preview-side" id="result" data-version="0"><div class="container am-engine" deep="8"><p><br data-filtered="filtered"></p><p><br data-filtered="filtered"></p><p>Redis 分布式锁使用 SET 指令就可以实现了么？在分布式领域 CAP 理论一直存在。</p><p>分布式锁的门道可没那么简单，我们在网上看到的分布式锁方案可能是有问题的。</p><p>一步步带你深入分布式锁是如何一步步完善，在高并发生产环境中如何正确使用分布式锁。</p><p>在进入正文之前，我们先带着问题去思考：</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>什么时候需要分布式锁？</li><li>加、解锁的代码位置有讲究么？</li><li>如何避免出现锁再也无法删除？</li><li>超时时间设置多少合适呢？</li><li>如何避免锁被其他线程释放</li><li>如何实现重入锁？</li><li>主从架构会带来什么安全问题？</li><li>什么是 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redlock​</code>​</li><li>Redisson 分布式锁最佳实战</li><li>看门狗实现原理</li><li>……<ul><li><br data-filtered="filtered"></li></ul></li></ul><p><strong>什么时候用分布式锁？</strong></p><p>❝说个通俗的例子讲解下什么时候需要分布式锁呢？</p><p>诊所只有一个医生，很多患者前来就诊。</p><p>医生在同一时刻只能给一个患者提供就诊服务。</p><p>如果不是这样的话，就会出现医生在就诊肾亏的「肖菜鸡」准备开药时候患者切换成了脚臭的「谢霸哥」，这时候药就被谢霸哥取走了。</p><p>治肾亏的药被有脚臭的拿去了。</p><p>当并发去读写一个【共享资源】的时候，我们为了保证数据的正确，需要控制同一时刻只有一个线程访问。</p><p><strong>分布式锁就是用来控制同一时刻，只有一个 JVM 进程中的一个线程可以访问被保护的资源。</strong></p><h2 id="h0"><br data-filtered="filtered"></h2><h2 id="h1">分布式锁入门</h2><p>❝65 哥：分布式锁应该满足哪些特性？</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>互斥：在任何给定时刻，只有一个客户端可以持有锁；</li><li>无死锁：任何时刻都有可能获得锁，即使获取锁的客户端崩溃；</li><li>容错：只要大多数 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redis​</code>​的节点都已经启动，客户端就可以获取和释放锁。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p>❝我可以使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SETNX key value​</code>​ 命令是实现「互斥」特性。</p><p>这个命令<span class="userCheck">来自</span>于​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET if Not eXists​</code>​​的缩写，意思是：如果 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​​ 不存在，则设置 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​value​</code>​​ 给这个​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​，否则啥都不做。Redis 官方地址说的：</p><p>命令的返回值：</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>1：设置成功；</li><li>0：key 没有设置成功。<ul><li><br data-filtered="filtered"></li></ul></li></ul><p>如下场景：</p><p>敲代码一天累了，想去放松按摩下肩颈。</p><p>168 号技师最抢手，大家喜欢点，所以并发量大，需要分布式锁控制。</p><p>同一时刻只允许一个「客户」预约 168 技师。</p><p>肖菜鸡申请 168 技师成功：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_0" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&gt; SETNX lock:168 1<br data-filtered="filtered">(integer) 1 # 获取 168 技师成功</div><ul class="pre-numbering" id="code_id_0" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><p>谢霸哥后面到，申请失败：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_1" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&gt; SETNX lock 2<br data-filtered="filtered">(integer) 0 # 客户谢霸哥 2 获取失败</div><ul class="pre-numbering" id="code_id_1" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><p>此刻，申请成功的客户就可以享受 168 技师的肩颈放松服务「共享资源」。</p><p>享受结束后，要及时释放锁，给后来者享受 168 技师的服务机会。</p><p>❝肖菜鸡，考考你如何释放锁呢？</p><p>很简单，使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​​ 删除这个 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​ 就行。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_2" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&gt; DEL lock:168<br data-filtered="filtered">(integer) 1</div><ul class="pre-numbering" id="code_id_2" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><p>❝你见过「龙」么？我见过，因为我被一条龙服务过。</p><p><img src="https://s2.51cto.com/images/blog/202112/07002301_61ae38e56527a53074.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 574px; height: 222px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_分布式"></p><p>肖菜鸡，事情可没这么简单。</p><p>这个方案存在一个存在造成锁无法释放的问题，造成该问题的场景如下：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>客户端所在节点崩溃，无法正确释放锁；</li><li>业务逻辑异常，无法执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​指令。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p>这样，这个锁就会一直占用，锁在我手里，我挂了，这样其他客户端再也拿不到这个锁了。</p><h2 id="h2"><br data-filtered="filtered"></h2><h2 id="h3">超时设置</h2><p>❝我可以在获取锁成功的时候设置一个「超时时间」</p><p>比如设定按摩服务一次 60 分钟，那么在给这个 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​ 加锁的时候设置 60 分钟过期即可：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_3" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&gt; SETNX lock:168 1  // 获取锁<br data-filtered="filtered">(integer) 1<br data-filtered="filtered">&gt; EXPIRE lock:168 60  // 60s 自动删除<br data-filtered="filtered">(integer) 1</div><ul class="pre-numbering" id="code_id_3" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li></ul></pre></div></div></div></div><p>这样，到点后锁自动释放，其他客户就可以继续享受 168 技师按摩服务了。</p><p>❝谁要这么写，就糟透了。</p><p>「加锁」、「设置超时」是两个命令，他们不是原子操作。</p><p><strong>如果出现只执行了第一条，第二条没机会执行就会出现「超时时间」设置失败，依然出现锁无法释放。</strong></p><p>❝那咋办，我想被一条龙服务，要解决这个问题</p><p>Redis 2.6.X 之后，官方拓展了 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET​</code>​ 命令的参数，满足了当 key 不存在则设置 value，同时设置超时时间的语义，并且满足原子性。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_4" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">SET resource_name random_value NX PX 30000</div><ul class="pre-numbering" id="code_id_4" style="display: block;"><li>1.</li></ul></pre></div></div></div></div><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>NX：表示只有 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​resource_name​</code>​ 不存在的时候才能 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET​</code>​ 成功，从而保证只有一个客户端可以获得锁；</li><li>PX 30000：表示这个锁有一个 30 秒自动过期时间。<ul><li><br data-filtered="filtered"></li></ul></li></ul><p>这样写还不够，我们还要防止不能释放不是自己加的锁。我们可以在 value 上做文章。</p><p>继续往下看……</p><h2 id="h4"><br data-filtered="filtered"></h2><h2 id="h5">释放了不是自己加的锁</h2><p>❝这样我能稳妥的享受一条龙服务了么？</p><p>No，还有一种场景会导致<strong>释放别人的锁</strong>：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>客户 1 获取锁成功并设置设置 30 秒超时；</li><li>客户 1 因为一些原因导致执行很慢（网络问题、发生 FullGC……），过了 30 秒依然没执行完，但是锁过期「自动释放了」；</li><li>客户 2 申请加锁成功；</li><li>客户 1 执行完成，执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​ 释放锁指令，这个时候就把客户 2 的锁给释放了。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p>有个关键问题需要解决：自己的锁只能自己来释放。</p><p>❝我要如何删除是自己加的锁呢？</p><p>在执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​ 指令的时候，我们要想办法检查下这个锁是不是自己加的锁再执行删除指令。</p><p><strong>解铃还须系铃人</strong></p><p>❝我在加锁的时候设置一个「唯一标识」作为 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​value​</code>​​ 代表加锁的客户端。​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET resource_name random_value NX PX 30000​</code>​在释放锁的时候，客户端将自己的「唯一标识」与锁上的「标识」比较是否相等，匹配上则删除，否则没有权利释放锁。</p><p>伪代码如下：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_5" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 比对 value 与 唯一标识<br data-filtered="filtered">if (redis.get("lock:168").equals(random_value)){<br data-filtered="filtered">   redis.del("lock:168"); //比对成功则删除<br data-filtered="filtered"> }</div><ul class="pre-numbering" id="code_id_5" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li></ul></pre></div></div></div></div><p>❝有没有想过，这是 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​GET + DEL​</code>​ 指令组合而成的，这里又会涉及到原子性问题。</p><p>我们可以通过 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Lua​</code>​ 脚本来实现，这样判断和删除的过程就是原子操作了。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_6" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 获取锁的 value 与 ARGV[1] 是否匹配，匹配则执行 del<br data-filtered="filtered">if redis.call("get",KEYS[1]) == ARGV[1] then<br data-filtered="filtered">    return redis.call("del",KEYS[1])<br data-filtered="filtered">else<br data-filtered="filtered">    return 0<br data-filtered="filtered">end</div><ul class="pre-numbering" id="code_id_6" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li></ul></pre></div></div></div></div><p>这样通过唯一值设置成 value 标识加锁的客户端很重要，仅使用 DEL 是不安全的，因为一个客户端可能会删除另一个客户端的锁。</p><p>使用上面的脚本，每个锁都用一个随机字符串“签名”，只有当删除锁的客户端的“签名”与锁的 value 匹配的时候，才会删除它。</p><p>官方文档也是这么说的：​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​https://redis.io/topics/distlock​</code>​</p><p>这个方案已经相对完美，我们用的最多的可能就是这个方案了。</p><h2 id="h6"><br data-filtered="filtered"></h2><h2 id="h7">正确设置锁超时</h2><p>❝锁的超时时间怎么计算合适呢？</p><p>这个时间不能瞎写，一般要根据在测试环境多次测试，然后压测多轮之后，比如计算出平均执行时间 200 ms。</p><p>那么锁的<strong>超时时间就放大为平均执行时间的 3~5 倍。</strong></p><p>❝为啥要放放大呢？</p><p>因为如果锁的操作逻辑中有网络 IO 操作、JVM FullGC 等，线上的网络不会总一帆风顺，我们要给网络抖动留有缓冲时间。</p><p>❝那我设置更大一点，比如设置 1 小时不是更安全？</p><p>不要钻牛角，多大算大？</p><p>设置时间过长，一旦发生宕机重启，就意味着 1 小时内，分布式锁的服务全部节点不可用。</p><p>你要让运维手动删除这个锁么？</p><p>只要运维真的不会打你。</p><p>❝有没有完美的方案呢？不管时间怎么设置都不大合适。</p><p>我们可以让获得锁的线程开启一个<strong>守护线程</strong>，用来给快要过期的锁「续航」。</p><p>加锁的时候设置一个过期时间，同时客户端开启一个「守护线程」，定时去检测这个锁的失效时间。</p><p><strong>如果快要过期，但是业务逻辑还没执行完成，自动对这个锁进行续期，重新设置过期时间。</strong></p><p>❝这个道理行得通，可我写不出。</p><p>别慌，已经有一个库把这些工作都封装好了他叫 <strong>Redisson</strong>。</p><p>在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p><p>❝一路优化下来，方案似乎比较「严谨」了，抽象出对应的模型如下。</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>通过 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​SET lock_resource_name random_value NX PX expire_time​</code>​，同时启动守护线程为快要过期但还没执行完的客户端的锁续命;</li><li>客户端执行业务逻辑操作共享资源；</li><li>通过 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Lua​</code>​ 脚本释放锁，先 get 判断锁是否是自己加的，再执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​DEL​</code>​。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p><img src="https://s2.51cto.com/images/blog/202112/07002301_61ae38e57532654850.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 691px; height: 386px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_java_02"></p><p>这个方案实际上已经比较完美，能写到这一步已经打败 90% 的程序猿了。</p><p>但是对于追求极致的程序员来说还远远不够：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>可重入锁如何实现？</li><li>主从架构崩溃恢复导致锁丢失如何解决？</li><li>客户端加锁的位置有门道么？<ol><li><br data-filtered="filtered"></li></ol></li></ol><h2 id="h8"><br data-filtered="filtered"></h2><h2 id="h9">加解锁代码位置有讲究</h2><p>根据前面的分析，我们已经有了一个「相对严谨」的分布式锁了。</p><p>于是「谢霸哥」就写了如下代码将分布式锁运用到项目中，以下是伪代码逻辑：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_7" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">public void doSomething() {<br data-filtered="filtered">  redisLock.lock(); // 上锁<br data-filtered="filtered">    try {<br data-filtered="filtered">        // 处理业务<br data-filtered="filtered">        .....<br data-filtered="filtered">        redisLock.unlock(); // 释放锁<br data-filtered="filtered">    } catch (Exception e) {<br data-filtered="filtered">        e.printStackTrace();<br data-filtered="filtered">    }<br data-filtered="filtered">}</div><ul class="pre-numbering" id="code_id_7" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li></ul></pre></div></div></div></div><p>❝有没有想过：一旦执行业务逻辑过程中抛出异常，程序就无法执行释放锁的流程。</p><p><strong>所以释放锁的代码一定要放在 </strong><strong>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​finally{}​</code>​ 块中。</strong></p><p>加锁的位置也有问题，放在 try 外面的话，如果执行 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​redisLock.lock()​</code>​ 加锁异常，但是实际指令已经发送到服务端并执行，只是客户端读取响应超时，就会导致没有机会执行解锁的代码。</p><p>所以 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​redisLock.lock()​</code>​ <strong>应该写在 try 代码块，这样保证一定会执行解锁逻辑。</strong></p><p>综上所述，正确代码位置如下 ：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_8" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">public void doSomething() {<br data-filtered="filtered">    try {<br data-filtered="filtered">        // 上锁<br data-filtered="filtered">        redisLock.lock();<br data-filtered="filtered">        // 处理业务<br data-filtered="filtered">        ...<br data-filtered="filtered">    } catch (Exception e) {<br data-filtered="filtered">        e.printStackTrace();<br data-filtered="filtered">    } finally {<br data-filtered="filtered">      // 释放锁<br data-filtered="filtered">      redisLock.unlock();<br data-filtered="filtered">    }<br data-filtered="filtered">}</div><ul class="pre-numbering" id="code_id_8" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li></ul></pre></div></div></div></div><h2 id="h10"><br data-filtered="filtered"></h2><h2 id="h11">实现可重入锁</h2><p>❝65 哥：可重入锁要如何实现呢？</p><p>当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的代码，可重入性就就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。</p><p>用一段代码解释可重入：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_9" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">public synchronized void a() {<br data-filtered="filtered">    b();<br data-filtered="filtered">}<br data-filtered="filtered">public synchronized void b() {<br data-filtered="filtered">    // pass<br data-filtered="filtered">}</div><ul class="pre-numbering" id="code_id_9" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li></ul></pre></div></div></div></div><p>假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时<strong>不可重入</strong>，线程就必须等待锁释放，再次争抢锁。</p><p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p><h2 id="h12">Redis Hash 可重入锁</h2><p>❝Redisson 类库就是通过 Redis Hash 来实现可重入锁</p><p>当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑。</p><p>退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。</p><p>可以看到可重入锁最大特性就是计数，计算加锁的次数。</p><p>所以当可重入锁需要在分布式环境实现时，我们也就需要统计加锁次数。</p><h3 id="h13">加锁逻辑</h3><p>❝我们可以使用 Redis hash 结构实现，key 表示被锁的共享资源， hash 结构的 fieldKey 的 value 则保存加锁的次数。</p><p><img src="https://s2.51cto.com/images/blog/202112/07002301_61ae38e59412152290.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 535px; height: 285px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_java_03"></p><p>通过 Lua 脚本实现原子性，假设 KEYS1 = 「lock」, ARGV「1000，uuid」：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_10" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">---- 1 代表 true<br data-filtered="filtered">---- 0 代表 false<br data-filtered="filtered">if (redis.call('exists', KEYS[1]) == 0) then<br data-filtered="filtered">    redis.call('hincrby', KEYS[1], ARGV[2], 1);<br data-filtered="filtered">    redis.call('pexpire', KEYS[1], ARGV[1]);<br data-filtered="filtered">    return 1;<br data-filtered="filtered">end ;<br data-filtered="filtered">if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then<br data-filtered="filtered">    redis.call('hincrby', KEYS[1], ARGV[2], 1);<br data-filtered="filtered">    redis.call('pexpire', KEYS[1], ARGV[1]);<br data-filtered="filtered">    return 1;<br data-filtered="filtered">end ;<br data-filtered="filtered">return 0;</div><ul class="pre-numbering" id="code_id_10" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li></ul></pre></div></div></div></div><p>加锁代码首先使用 Redis ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​exists​</code>​ 命令判断当前 lock 这个锁是否存在。</p><p>如果锁不存在的话，直接使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hincrby​</code>​​创建一个键为 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​lock​</code>​​ hash 表，并且为 Hash 表中键为 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​uuid​</code>​ 初始化为 0，然后再次加 1，最后再设置过期时间。</p><p>如果当前锁存在，则使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hexists​</code>​​判断当前 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​lock​</code>​​ 对应的 hash 表中是否存在 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​uuid​</code>​​ 这个键，如果存在，再次使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hincrby​</code>​ 加 1，最后再次设置过期时间。</p><p>最后如果上述两个逻辑都不符合，直接返回。</p><h3 id="h14">解锁逻辑</h3><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_11" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">-- 判断 hash set 可重入 key 的值是否等于 0<br data-filtered="filtered">-- 如果为 0 代表 该可重入 key 不存在<br data-filtered="filtered">if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then<br data-filtered="filtered">    return nil;<br data-filtered="filtered">end ;<br data-filtered="filtered">-- 计算当前可重入次数<br data-filtered="filtered">local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1);<br data-filtered="filtered">-- 小于等于 0 代表可以解锁<br data-filtered="filtered">if (counter &gt; 0) then<br data-filtered="filtered">    return 0;<br data-filtered="filtered">else<br data-filtered="filtered">    redis.call('del', KEYS[1]);<br data-filtered="filtered">    return 1;<br data-filtered="filtered">end ;<br data-filtered="filtered">return nil;</div><ul class="pre-numbering" id="code_id_11" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li><li>14.</li><li>15.</li></ul></pre></div></div></div></div><p>首先使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hexists​</code>​ 判断 Redis Hash 表是否存给定的域。</p><p>如果 lock 对应 Hash 表不存在，或者 Hash 表不存在 uuid 这个 key，直接返回 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​nil​</code>​。</p><p>若存在的情况下，代表当前锁被其持有，首先使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​hincrby​</code>​​使可重入次数减 1 ，然后判断计算之后可重入次数，若小于等于 0，则使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​del​</code>​ 删除这把锁。</p><p>解锁代码执行方式与加锁类似，只不过解锁的执行结果返回类型使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Long​</code>​​。这里之所以没有跟加锁一样使用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Boolean​</code>​ ,这是因为解锁 lua 脚本中，三个返回值含义如下：</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>1 代表解锁成功，锁被释放</li><li>0 代表可重入次数被减 1</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​null​</code>​ 代表其他线程尝试解锁，解锁失败.<ul><li><br data-filtered="filtered"></li></ul></li></ul><h2 id="h15"><br data-filtered="filtered"></h2><h2 id="h16">主从架构带来的问题</h2><p>❝到这里分布式锁「很完美了」吧，没想到分布式锁这么多门道。</p><p>路还很远，之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 主从模式导致的问题。</p><p>我们通常使用「Cluster 集群」或者「哨兵集群」的模式部署保证高可用。</p><p>这两个模式都是基于「主从架构数据同步复制」实现的数据同步，而 Redis 的主从复制默认是异步的。</p><p><br data-filtered="filtered"></p><p>我们试想下如下场景会发生什么问题：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>客户端 A 在 master 节点获取锁成功。</li><li>还没有把获取锁的信息同步到 slave 的时候，master 宕机。</li><li>slave 被选举为新 master，这时候没有客户端 A 获取锁的数据。</li><li>客户端 B 就能成功的获得客户端 A 持有的锁，违背了分布式锁定义的互斥。<ol><li><br data-filtered="filtered"></li></ol></li></ol><p>虽然这个概率极低，但是我们必须得承认这个风险的存在。</p><p>❝Redis 的作者提出了一种解决方案，叫 Redlock（红锁）</p><p>Redis 的作者为了统一分布式锁的标准，搞了一个 Redlock，算是 Redis 官方对于实现分布式锁的指导规范，https://redis.io/topics/distlock，但是这个 Redlock 也被国外的一些分布式专家给喷了。</p><p>因为它也不完美，有“漏洞”。</p><h2 id="h17"><br data-filtered="filtered"></h2><h2 id="h18">什么是 Redlock</h2><p>红锁是不是这个？</p><p><img src="https://s2.51cto.com/images/blog/202112/07002301_61ae38e5b20c178468.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 603px; height: 626px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_分布式_04"></p><p>泡面吃多了你，​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redlock​</code>​ 红锁是为了解决主从架构中当出现主从切换导致多个客户端持有同一个锁而提出的一种算法。</p><p><br data-filtered="filtered"></p><p>想用使用 Redlock，官方建议在不同机器上部署 5 个 Redis 主节点，节点都是完全独立，也不使用主从复制，使用多个节点是为容错。</p><p><strong>一个客户端要获取锁有 5 个步骤</strong>：</p><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li>客户端获取当前时间 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​T1​</code>​（毫秒级别）；</li><li>使用相同的 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​key​</code>​和 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​value​</code>​顺序尝试从 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​N​</code>​个 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redis​</code>​实例上获取锁。<ol><li><br data-filtered="filtered"></li></ol></li></ol><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>每个请求都设置一个超时时间（毫秒级别），该超时时间要远小于锁的有效时间，这样便于快速尝试与下一个实例发送请求。</li><li>比如锁的自动释放时间 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​10s​</code>​，则请求的超时时间可以设置 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​5~50​</code>​ 毫秒内，这样可以防止客户端长时间阻塞。<ul><li><br data-filtered="filtered"></li></ul></li></ul><p>客户端获取当前时间 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​T2​</code>​​ 并减去步骤 1 的 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​T1​</code>​​ 来计算出获取锁所用的时间（​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​T3 = T2 -T1​</code>​）。<strong>当且仅当客户端在大多数实例（</strong><strong>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​N/2 + 1​</code>​）获取成功，且获取锁所用的总时间 T3 小于锁的有效时间，才认为加锁成功，否则加锁失败。</strong></p><p>如果第 3 步加锁成功，则执行业务逻辑操作共享资源，<strong>key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</strong></p><p>如果因为某些原因，获取锁失败（没有在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），<strong>客户端应该在所有的 Redis 实例上进行解锁</strong>（即便某些 Redis 实例根本就没有加锁成功）。</p><p><strong>另外部署实例的数量要求是奇数，为了能很好的满足过半原则，如果是 6 台则需要 4 台获取锁成功才能认为成功，所以奇数更合理</strong></p><p>❝事情可没这么简单，Redis 作者把这个方案提出后，受到了业界著名的分布式系统专家的<strong>质疑</strong>。</p><p>两人好比神仙打架，两人一来一回论据充足的对一个问题提出很多论断……</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li><br data-filtered="filtered"><ul><li><br data-filtered="filtered"></li></ul></li></ul><h2 id="h19">Redlock 是与非</h2><p>Martin Kleppmann 认为锁定的目的是为了保护对共享资源的读写，而分布式锁应该「高效」和「正确」。</p><ul><li><ul><li><br data-filtered="filtered"></li></ul></li><li>高效性：分布式锁应该要满足高效的性能，Redlock 算法向 5 个节点执行获取锁的逻辑性能不高，成本增加，复杂度也高；</li><li>正确性：分布式锁应该防止并发进程在同一时刻只能有一个线程能对共享数据读写。<ul><li><br data-filtered="filtered"></li></ul></li></ul><p>出于这两点，我们没必要承担 Redlock 的成本和复杂，运行 5 个 Redis 实例并判断加锁是否满足大多数才算成功。</p><p>主从架构崩溃恢复极小可能发生，这没什么大不了的。使用单机版就够了，Redlock 太重了，没必要。</p><p><strong>Martin</strong> 认为 <strong>Redlock</strong> 根本达不到安全性的要求，也依旧存在锁失效的问题！</p><h3 id="h20">Martin 的结论</h3><ol><li><ol><li><br data-filtered="filtered"></li></ol></li><li><strong>Redlock</strong> 不伦不类：对于偏好效率来讲，<strong>Redlock</strong> 比较重，没必要这么做，而对于偏好正确性来说，<strong>Redlock</strong> 是不够安全的。</li><li>时钟假设不合理：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</li><li>无法保证正确性：<strong>Redlock</strong> 不能提供类似 <strong>fencing token</strong> 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 <strong>Zookeeper</strong>。<ol><li><br></li></ol></li></ol><h2 id="h21">Redis 作者 Antirez 的反驳</h2><p>在 <strong>Redis</strong> 作者的反驳文章中，有 3 个重点：</p><ul><li><ul><li><br></li></ul></li><li>时钟问题：<strong>Redlock</strong> 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」，只要误差不要超过锁的租期即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</li><li>网络延迟、进程暂停问题：</li><li><ul><li><ul><li><br></li></ul></li><li>客户端在拿到锁之前，无论经历什么耗时长问题，<strong>Redlock</strong> 都能够在第 3 步检测出来</li><li>客户端在拿到锁之后，发生 <strong>NPC</strong>，那 <strong>Redlock、Zookeeper</strong> 都无能为力<ul><li><br></li></ul></li></ul></li><li>质疑 fencing token 机制。<ul><li><br></li></ul></li></ul><p>关于 Redlock 的争论我们下期再见，现在进入 Redisson 实现分布式锁实战部分。</p><h2 id="h22"><br></h2><h2 id="h23">Redisson 分布式锁</h2><p>基于 SpringBoot starter 方式，添加 starter。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_12" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&lt;dependency&gt;<br>  &lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>  &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;<br>  &lt;version&gt;3.16.4&lt;/version&gt;<br>&lt;/dependency&gt;</div><ul class="pre-numbering" id="code_id_12" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li></ul></pre></div></div></div></div><p>不过这里需要注意 springboot 与 redisson 的版本，因为官方推荐 redisson 版本与 springboot 版本配合使用。</p><p>将 Redisson 与 Spring Boot 库集成，还取决于 Spring Data Redis 模块。</p><p>使用 SpringBoot 2.5.x 版本， 所以需要添加 redisson-spring-data-25。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_13" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">&lt;dependency&gt;<br>  &lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>  &lt;!-- for Spring Data Redis v.2.5.x --&gt;<br>  &lt;artifactId&gt;redisson-spring-data-25&lt;/artifactId&gt;<br>  &lt;version&gt;3.16.4&lt;/version&gt;<br>&lt;/dependency&gt;</div><ul class="pre-numbering" id="code_id_13" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li></ul></pre></div></div></div></div><p>添加配置文件</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_14" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">spring:<br>  redis:<br>    database:<br>    host:<br>    port:<br>    password:<br>    ssl:<br>    timeout:<br>    # 根据实际情况配置 cluster 或者哨兵<br>    cluster:<br>      nodes:<br>    sentinel:<br>      master:<br>      nodes:</div><ul class="pre-numbering" id="code_id_14" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li><li>14.</li></ul></pre></div></div></div></div><p>就这样在 Spring 容器中我们拥有以下几个 Bean 可以使用:</p><ul><li><ul><li><br></li></ul></li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​RedissonClient​</code>​</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​RedissonRxClient​</code>​</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​RedissonReactiveClient​</code>​</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​RedisTemplate​</code>​</li><li>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​ReactiveRedisTemplate​</code>​<ul><li><br></li></ul></li></ul><h2 id="h24">失败无限重试</h2><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_15" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">RLock lock = redisson.getLock("AAA");<br>try {<br><br>  // 1.最常用的第一种写法<br>  lock.lock();<br><br>  // 执行业务逻辑<br>  .....<br><br>} finally {<br>  lock.unlock();<br>}</div><ul class="pre-numbering" id="code_id_15" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li></ul></pre></div></div></div></div><p>拿锁失败时会不停的重试，具有 Watch Dog 自动延期机制，默认续 30s 每隔 30/3=10 秒续到 30s。</p><h2 id="h25">失败超时重试，自动续命</h2><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_16" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 尝试拿锁10s后停止重试,获取失败返回false，具有Watch Dog 自动延期机制， 默认续30s<br>boolean flag = lock.tryLock(10, TimeUnit.SECONDS);</div><ul class="pre-numbering" id="code_id_16" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><h2 id="h26">超时自动释放锁</h2><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_17" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 没有Watch Dog ，10s后自动释放,不需要调用 unlock 释放锁。<br>lock.lock(10, TimeUnit.SECONDS);</div><ul class="pre-numbering" id="code_id_17" style="display: block;"><li>1.</li><li>2.</li></ul></pre></div></div></div></div><h2 id="h27">超时重试，自动解锁</h2><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_18" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁,没有 Watch dog<br>boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);<br>if (res) {<br>   try {<br>     ...<br>   } finally {<br>       lock.unlock();<br>   }<br>}</div><ul class="pre-numbering" id="code_id_18" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li></ul></pre></div></div></div></div><h2 id="h28">Watch Dog 自动延时</h2><p>如果获取分布式锁的节点宕机，且这个锁还处于锁定状态，就会出现死锁。</p><p>为了避免这个情况，我们都会给锁设置一个超时自动释放时间。</p><p>然而，还是会存在一个问题。</p><p>假设线程获取锁成功，并设置了 30 s 超时，但是在 30s 内任务还没执行完，锁超时释放了，就会导致其他线程获取不该获取的锁。</p><p>所以，Redisson 提供了 watch dog 自动延时机制，提供了一个监控锁的看门狗，它的作用是在 Redisson 实例被关闭前，不断的延长锁的有效期。</p><p>也就是说，如果一个拿到锁的线程一直没有完成逻辑，那么看门狗会帮助线程不断的延长锁超时时间，锁不会因为超时而被释放。</p><p>默认情况下，看门狗的续期时间是 30s，也可以通过修改 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Config.lockWatchdogTimeout​</code>​ 来另行指定。</p><p>另外 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​Redisson​</code>​​ 还提供了可以指定 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​leaseTime​</code>​ 参数的加锁方法来指定加锁的时间。</p><p>超过这个时间后锁便自动解开了，不会延长锁的有效期。</p><p>原理如下图：</p><p><img src="https://s2.51cto.com/images/blog/202112/07002302_61ae38e61dcac76212.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" style="visibility: visible; width: 100%; height: 734px;" alt="Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结_多线程_05"></p><p><strong>有两个点需要注意：</strong></p><ul><li><ul><li><br></li></ul></li><li><strong>watchDog 只有在未显示指定加锁超时时间（leaseTime）时才会生效。</strong></li><li><strong>lockWatchdogTimeout 设定的时间不要太小 ，比如设置的是 100 毫秒，由于网络直接导致加锁完后，watchdog 去延期时，这个 key 在 redis 中已经被删除了。</strong><ul><li><br></li></ul></li></ul><h2 id="h29">源码导读</h2><p>在调用 lock 方法时，会最终调用到 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​tryAcquireAsync​</code>​。</p><p>调用链为：​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​lock()-&gt;tryAcquire-&gt;tryAcquireAsync​</code>​，详细解释如下：</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_19" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {<br>        RFuture&lt;Long&gt; ttlRemainingFuture;<br>        //如果指定了加锁时间，会直接去加锁<br>        if (leaseTime != -1) {<br>            ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);<br>        } else {<br>            //没有指定加锁时间 会先进行加锁，并且默认时间就是 LockWatchdogTimeout的时间<br>            //这个是异步操作 返回RFuture 类似netty中的future<br>            ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,<br>                    TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<br>        }<br><br>        //这里也是类似netty Future 的addListener，在future内容执行完成后执行<br>        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; {<br>            if (e != null) {<br>                return;<br>            }<br><br>            // lock acquired<br>            if (ttlRemaining == null) {<br>                // leaseTime不为-1时，不会自动延期<br>                if (leaseTime != -1) {<br>                    internalLockLeaseTime = unit.toMillis(leaseTime);<br>                } else {<br>                    //这里是定时执行 当前锁自动延期的动作,leaseTime为-1时，才会自动延期<br>                    scheduleExpirationRenewal(threadId);<br>                }<br>            }<br>        });<br>        return ttlRemainingFuture;<br>    }</div><ul class="pre-numbering" id="code_id_19" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li><li>14.</li><li>15.</li><li>16.</li><li>17.</li><li>18.</li><li>19.</li><li>20.</li><li>21.</li><li>22.</li><li>23.</li><li>24.</li><li>25.</li><li>26.</li><li>27.</li><li>28.</li><li>29.</li><li>30.</li><li>31.</li></ul></pre></div></div></div></div><p>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​scheduleExpirationRenewal​</code>​​ 中会调用 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​renewExpiration​</code>​​ 启用了一个 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​timeout​</code>​ 定时，去执行延期动作。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_20" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">private void renewExpiration() {<br>        ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>        if (ee == null) {<br>            return;<br>        }<br><br>        Timeout task = commandExecutor.getConnectionManager()<br>          .newTimeout(new TimerTask() {<br>            @Override<br>            public void run(Timeout timeout) throws Exception {<br>                // 省略部分代码<br>                ....<br><br>                RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);<br>                future.onComplete((res, e) -&gt; {<br>                    ....<br><br>                    if (res) {<br>                        //如果 没有报错，就再次定时延期<br>                        // reschedule itself<br>                        renewExpiration();<br>                    } else {<br>                        cancelExpirationRenewal(null);<br>                    }<br>                });<br>            }<br>            // 这里我们可以看到定时任务 是 lockWatchdogTimeout 的1/3时间去执行 renewExpirationAsync<br>        }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);<br><br>        ee.setTimeout(task);<br>    }</div><ul class="pre-numbering" id="code_id_20" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li><li>11.</li><li>12.</li><li>13.</li><li>14.</li><li>15.</li><li>16.</li><li>17.</li><li>18.</li><li>19.</li><li>20.</li><li>21.</li><li>22.</li><li>23.</li><li>24.</li><li>25.</li><li>26.</li><li>27.</li><li>28.</li><li>29.</li><li>30.</li><li>31.</li></ul></pre></div></div></div></div><p>​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​scheduleExpirationRenewal​</code>​​ 会调用到 ​<code style="font-family:monospace;font-size:inherit;background-color:rgba(0,0,0,.06);padding:0px 2px;line-height:inherit;text-indent:0px;">​renewExpirationAsync​</code>​，执行下面这段 lua 脚本。</p><p>他主要判断就是 这个锁是否在 redis 中存在，如果存在就进行 pexpire 延期。</p><div><div class="data-codeblock-content" style="border:1px solid rgb(232,232,232);max-width:750px;color:rgb(38,38,38);margin:0px;padding:0px;background:rgb(249,249,249);"><div class="CodeMirror" style="color:rgb(89,89,89);margin:0px;padding:16px;background:rgba(0,0,0,0) none repeat scroll 0% 0%;"><div class="hljs-cto"><div class="operation_box"><button data-clipboard-target="#code_id_21" class="copy_btn disable">登录后复制</button> <a title="登录后一键下载全文代码" class="downloadCode"><i class="iconblog blogimport  "></i></a> </div><pre class="cm-s-default has-pre-numbering" style="color: rgb(89, 89, 89); margin: 0px; padding: 15px 0px 17px; background: none 0% 0% repeat scroll rgba(0, 0, 0, 0);"><div class="language-">protected RFuture&lt;Boolean&gt; renewExpirationAsync(long threadId) {<br>        return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,<br>                "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +<br>                        "redis.call('pexpire', KEYS[1], ARGV[1]); " +<br>                        "return 1; " +<br>                        "end; " +<br>                        "return 0;",<br>                Collections.singletonList(getRawName()),<br>                internalLockLeaseTime, getLockName(threadId));<br>    }</div><ul class="pre-numbering" id="code_id_21" style="display: block;"><li>1.</li><li>2.</li><li>3.</li><li>4.</li><li>5.</li><li>6.</li><li>7.</li><li>8.</li><li>9.</li><li>10.</li></ul></pre></div></div></div></div><ul><li><ul><li><br></li></ul></li><li>watch dog 在当前节点还存活且任务未完成则每 10 s 给锁续期 30s。</li><li>程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中；</li><li>要使 watchLog 机制生效 ，lock 时 不要设置 过期时间。</li><li>watchlog 的延时时间 可以由 lockWatchdogTimeout 指定默认延时时间，但是不要设置太小。</li><li>watchdog 会每 lockWatchdogTimeout/3 时间，去延时。</li><li>通过 lua 脚本实现延迟。<ul><li><br></li></ul></li></ul><h2 id="h30">、</h2><p><br></p></div></div>
                    </div>

                    <div id="asideoffset"></div>
                    <div class="clearfix label-list">

                        <!--            <span>本文包含：</span>-->
                        <!--          -->
                        <!--            <a href="" target="_blank"></a>-->

                    </div>
                </div>
                <div class="action-box">
                    <ul>
                        <li>
                            <strong class="is-praise  " type="1" blog_id="4761555" userid="13616762">
                                <a href="javascript:;"><i></i></a>
                                <span><b class="praise-num"></b>赞</span>
                            </strong>
                        </li>
                        <li>
                            <strong class="favorites-opt">
                                <a href="javascript:;"><i></i></a>
                                <span><b class="favorites-num"></b>收藏</span>
                            </strong>
                        </li>
                        <li>
                            <strong class="Topraise">
                                <a href="javascript:;"><i class="iconblog blogpinglun"></i></a>
                                <span><b class="comments_num"></b>评论</span>
                            </strong>
                        </li>
                        <li class="share">
                            <strong class="">
                                <a href="javascript:;"><i class="iconblog blogfen"></i></a>
                                <span>分享</span>
                            </strong>
                        </li>
                        <li>
                            <strong class="article-report">
                                <a href="javascript:;"><i class="iconblog blogjubaobeifen report-icon" style="font-size: 23px"></i></a>
                                <span>举报</span>
                            </strong>
                        </li>
                    </ul>
                </div>
                <div class="clearfix lists">
                    <p class="fl"><span>上一篇：</span><a href="https://blog.51cto.com/u_13626762/4761534">程序员敲诈老板，或面临 37 年监禁</a></p>
                    <p class="fr"><span>下一篇：</span><a href="https://blog.51cto.com/u_13626762/4761600">我的十年程序员生涯</a></p>
                </div>
                <div class="text-aticle">

                </div>
            </div>


            <div class="common-section common-spacing mb30 comment-box" id="comment">
                <div class="comment-textarea clearfix">
                    <div class="avatar">
                        <a href="https://blog.51cto.com/" class="header-img" target="_blank">
                            <img src="https://ucenter.51cto.com/images/noavatar_middle.gif">
                        </a>
                    </div>
                    <div class="textarea-box">
                        <div class="textarea-show clearfix">
                            <span>提问和评论都可以，用心的回复会被更多人看到</span>
                            <strong>评论</strong>
                        </div>
                        <div class="textarea-hide">
                            <div class="top">
                                <textarea class="textareadiv textareadiv-publish" name="" id="textareadiv-publish" placeholder="提问和评论都可以，用心的回复会被更多人看到和认可" maxlength="500"></textarea>
                            </div>
                            <div class="bot clearfix">
                                <strong class="fr publish-btn" flag="1" id="publish-btn">发布评论</strong>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="comment-num" style="display:none;">
                    <strong>全部评论</strong>
                    <span>(<b id="CommentNum"></b>)</span>
                    <span class="fr sort" type="up_num" order="0"><i class="iconblog blogzuire"></i>最热</span>
                    <span class="fr sort on" type="create_time" order="0"><i class="iconblog blogzuixinblogzuixin"></i>最新</span>
                </div>
                <div class="comment-List-box"></div>
            </div>

            <section class="common-section common-spacing mb30">
                <div class="clearfix common-sub-title">
                    <strong>相关文章</strong>
                </div>
                <ul class="recommend-about">
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_12099683/3689370" data-report-query="xiangguantuijian&amp;01" target="_blank" class="title">
                                <div class="tit">redis分布式锁redisson实现原理</div>
                                <p> 一致性，但是具备高可用，性能高zookeeper：使用的是CP，强一致性和分区容错性。只有当zookeeper集群半数以上的节点数据同步ok了，才返回给客户端成功，redis是只要master成...</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         zookeeper                                    </span>
                                <span class="tag-item">
                                         高可用                                    </span>
                                <span class="tag-item">
                                         分布式锁                                    </span>
                                <span class="tag-item">
                                         强一致性                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_15061948/4343153" data-report-query="xiangguantuijian&amp;02" target="_blank" class="title">
                                <div class="tit">Redis分布式锁的正确实现方式</div>
                                <p> Redis分布式锁的正确实现方式 前言 分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题 ...</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         客户端                                    </span>
                                <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         加锁                                    </span>
                                <span class="tag-item">
                                         分布式锁                                    </span>
                                <span class="tag-item">
                                         lua                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_15912066/5936248" data-report-query="xiangguantuijian&amp;03" target="_blank" class="title">
                                <div class="tit">redis分布式锁 Redisson的原理</div>
                                <p> 第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         Redisson                                    </span>
                                <span class="tag-item">
                                         加锁                                    </span>
                                <span class="tag-item">
                                         客户端                                    </span>
                                <span class="tag-item">
                                         redis                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_12004792/3140271" data-report-query="xiangguantuijian&amp;04" target="_blank" class="title">
                                <div class="tit">Redis(十三):Redis分布式锁的正确实现方式</div>
                                <p> 前言 分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         分布式                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_12902932/1924602" data-report-query="xiangguantuijian&amp;05" target="_blank" class="title">
                                <div class="tit">redisson实现分布式锁原理</div>
                                <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redisson分布式锁之前的基于注解的锁有一种锁是基本redis的分布式锁，锁的实现我是基于redisson组件提供的RLock，这篇来看看redisson是如何实现锁的。不同版本实现锁的机制并不相同引用的redisson最近发布的版本3.2.3，不同的版本可能实现锁的机制并不相同，早期版本好像是采用</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         接口                                    </span>
                                <span class="tag-item">
                                         如何                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_15127691/4371758" data-report-query="xiangguantuijian&amp;06" target="_blank" class="title">
                                <div class="tit">Redis实战-Redisson-分布式锁</div>
                                <p> 1. 简介 随着技术的快速发展，业务系统规模的不断扩大，分布式系统越来越普及。一个应用往往会部署到多台机器上，在一些业务场景中，为了保证数据的一致性，要求在同一时刻，同一任务只在一个节点上运行，保证同一个方法同一时刻只能被一个线程执行。这时候分布式锁就运用而生了。 分布式锁有很多的解决方案。常见的有 ...</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         SpringBoot                                    </span>
                                <span class="tag-item">
                                         Redis                                    </span>
                                <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         测试方法                                    </span>
                                <span class="tag-item">
                                         spring                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_11579569/5522147" data-report-query="xiangguantuijian&amp;07" target="_blank" class="title">
                                <div class="tit">【分布式缓存Redis】Redisson原理与实战</div>
                                <p> :18P165 165、 缓存-分布式锁Red</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redission                                    </span>
                                <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         分布式锁                                    </span>
                                <span class="tag-item">
                                         缓存                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_15912066/6084951" data-report-query="xiangguantuijian&amp;08" target="_blank" class="title">
                                <div class="tit">Redisson分布式锁的实现原理</div>
                                <p> 一、写在前面现在面试，一般都会聊聊分布式系统这块的东西。通常面试官都会从服务框架（Spring Cloud、Dubbo）聊起，一路聊到分布式事务、分布式锁、ZooKeeper等知识。所以咱们这篇文章就来聊聊分布式锁这块知识，具体的来看看Redis分布式锁的实现原理。说实话，如果在公司里落地生产环境用分布式锁的时候，一定是会用开源类库的，比如Redis分布式锁，一般就是用Redisson框架就好了，</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redisson                                    </span>
                                <span class="tag-item">
                                         redission原理                                    </span>
                                <span class="tag-item">
                                         redisson分布式锁                                    </span>
                                <span class="tag-item">
                                         Powered by 金山文档                                    </span>
                                <span class="tag-item">
                                         加锁                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_11579569/5948504" data-report-query="xiangguantuijian&amp;09" target="_blank" class="title">
                                <div class="tit">【分布式锁】Redis和Redisson原理与应用</div>
                                <p> 一、参考资料​​EhCache - 简书​​​​阿里云Redis开发规范-阿里云开发者社区​​</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redis                                    </span>
                                <span class="tag-item">
                                         redisson                                    </span>
                                <span class="tag-item">
                                         分布式锁                                    </span>
                                <span class="tag-item">
                                         Redis                                    </span>
                                <span class="tag-item">
                                         缓存                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/zhangxueliang/3000235" data-report-query="xiangguantuijian&amp;10" target="_blank" class="title">
                                <div class="tit">Redisson实现分布式锁原理及代码实战</div>
                                <p> Redission分布式锁原理实现Redis的分布式锁，除了自己基于redis client原生api来实现之外，还可以使用开源框架：RedissionRedisson是一个企业级的开源Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？回想一下上面说的，如果自己写代码来通过redis设置一个值，是通过下面这个命令设置的。SET anyLock unique...</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         redis                                    </span>
                            </div>
                        </div>

                    </li>
                    <li>
                        <div class="about-aticle-list">
                            <a href="https://blog.51cto.com/u_13672582/2320328" data-report-query="" target="_blank" class="title">
                                <div class="tit">Redis分布式锁的正确实现方式（Java版）</div>
                                <p> 前言分布式锁一般有三种实现方式：1.数据库乐观锁；2.基于Redis的分布式锁；3.基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。可靠性首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四</p>
                            </a>
                            <!-- 标签页 -->
                            <div class="tag-box">
                                                                    <span class="tag-item">
                                         JAVA                                    </span>
                            </div>
                        </div>

                    </li>
                </ul>
            </section>

        </article>

        <aside class="detail-content-right">
            <!--右上角统计-->
            <section class="common-section common-spacing mb24 user-intr" style="visibility: hidden;">
                <div class="user-content">
                    <div class="top">
                        <div class="avatar">
                            <div class="avatar-img">
                                <a href="https://blog.51cto.com/u_13626762" target="_blank" rel="nofollow">
                                    <img class="is-vip-img is-vip-img-4" data-uid="13616762" src="https://s2.51cto.com/oss/201904/09/9210cdc5924b0d7be8b3599dc11eb6be.jpg?x-oss-process=image/format,webp/ignore-error,1">
                                </a>
                            </div>
                        </div>
                        <div class="clearfix username">
                            <a href="https://blog.51cto.com/u_13626762" target="_blank"><span class="blog-user" title="Hollis在51CTO" style="max-width: 272px;">Hollis在51CTO</span></a>
                            <div class="icon">
                                <ul class="clearfix detail-list"></ul>
                            </div>
                        </div>
                    </div>
                    <div class="identify-list"></div>
                    <div class="bottom" id="userStat"><div class="num-name num-top">
                        <ul class="first-num">
                            <li>
                                <div class="num"><a href="https://blog.51cto.com/u_13626762/original" target="_blank" rel="nofollow">611</a></div>
                                <div class="label-name"><a href="https://blog.51cto.com/u_13626762/original" target="_blank" rel="nofollow">原创</a></div>
                            </li>
                            <li>
                                <div class="num">108.1<span>万</span></div>
                                <div class="label-name">人气</div>
                            </li>
                            <li>
                                <div class="num"><a href="https://blog.51cto.com/u_13626762/followers" target="_blank" rel="nofollow">43<span></span></a></div>
                                <div class="label-name"><a href="https://blog.51cto.com/u_13626762/followers" target="_blank" rel="nofollow">粉丝</a></div>
                            </li>
                            <li>
                                <div class="num">4<span></span></div>
                                <div class="label-name">评论</div>
                            </li>
                        </ul>
                    </div>
                        <div class="lines"></div>
                        <div class="num-name num-bottom">
                            <ul>
                                <li>
                                    <div class="num"><a href="https://blog.51cto.com/u_13626762/translate" target="_blank" rel="nofollow">0</a></div>
                                    <div class="label-name"><a href="https://blog.51cto.com/u_13626762/translate" target="_blank" rel="nofollow">翻译</a></div>
                                </li>
                                <li>
                                    <div class="num"><a href="https://blog.51cto.com/u_13626762/reproduce" target="_blank" rel="nofollow">2947</a></div>
                                    <div class="label-name"><a href="https://blog.51cto.com/u_13626762/reproduce" target="_blank" rel="nofollow">转载</a></div>
                                </li>
                                <li>
                                    <div class="num"><a href="https://blog.51cto.com/u_13626762/following" target="_blank" rel="nofollow">1</a></div>
                                    <div class="label-name"><a href="https://blog.51cto.com/u_13626762/following" target="_blank" rel="nofollow">关注</a></div>
                                </li>
                                <li>
                                    <div class="num">26</div>
                                    <div class="label-name">收藏</div>
                                </li>
                                <div class="clear"></div>
                            </ul>
                        </div></div>
                    <div id="medalListBox" class="medal-list"><div title="知名人士" class="medalItem item"><img src="https://s2.51cto.com/images/202203/15ab11299b3053d6c281582e1acf449c18b312.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="一眼万年" class="medalItem item"><img src="https://s2.51cto.com/images/202203/195f76d50ffb2cd8b16664147e48ea8edd9fd6.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="锋芒毕露" class="medalItem item"><img src="https://s2.51cto.com/images/202203/f6f53e943b8feeab330770a0ec42efed855946.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="崭露头角" class="medalItem item"><img src="https://s2.51cto.com/images/202203/31b28da6607cbc93cd900122f89b19420ac8c5.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="自成一派" class="medalItem item"><img src="https://s2.51cto.com/images/202203/81ba9de79b69d05f4333211abd2d0d4a008a05.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="一代宗师" class="medalItem item"><img src="https://s2.51cto.com/images/202202/61ba4e730b80264ca0076678a0dbd3e16f64bb.png?&amp;x-oss-process=image/format,webp"></div><div title="炉火纯青" class="medalItem item"><img src="https://s2.51cto.com/images/202202/c1c0bc692d7397c63280391ec9fc97b029aa51.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="博闻强识" class="medalItem item"><img src="https://s2.51cto.com/images/202202/a8ef82362559226c848000f191ce5a08f03207.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="持之以恒" class="medalItem item"><img src="https://s2.51cto.com/images/202202/b67592a476d24a33731174926f050c7209f5df.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div><div title="挑战自我" class="medalItem item"><img src="https://s2.51cto.com/images/202202/03ea5c8040c00c2cbaf04751aae5540380427a.png?x-oss-process=image/format,webp/resize,h_96,w_107"></div></div>
                    <div class="operating clearfix ">
                        <a id="checkFollow2_13616762" class="follow-1 checkFollow on" rel="nofollow">关注</a>
                        <button class="sx" data="https://home.51cto.com/space?uid=13616762" id="ToSx"><a href="javascript:;" rel="nofollow"><i class="iconblog blogsixin"></i>私信</a></button>
                    </div>
                </div>
            </section>

            <!-- 分类列表 -->
            <!-- 近期文章 -->
            <section class="common-section common-spacing mb24" style="visibility: hidden;">
                <div class="clearfix common-sub-title">
                    <strong title="近期文章">近期文章</strong>
                </div>
                <ul class="common-list">
                    <li>
                        <a href="https://blog.51cto.com/u_15618380/6168766" target="_blank" title="屏幕录制软件有哪些？屏幕录制软件分享！​">1.屏幕录制软件有哪些？屏幕录制软件分享！​</a>
                    </li>
                    <li>
                        <a href="https://blog.51cto.com/u_15905566/6168643" target="_blank" title="鹏业软件为中国电子系统工程第三建设有限公司开展企业定制培训">2.鹏业软件为中国电子系统工程第三建设有限公司开展企业定制培训</a>
                    </li>
                    <li>
                        <a href="https://blog.51cto.com/u_15994668/6168674" target="_blank" title="倒计时，4.21日第15届CBE中国电池展，台湾高技与您展会见！">3.倒计时，4.21日第15届CBE中国电池展，台湾高技与您展会见！</a>
                    </li>
                    <li>
                        <a href="https://blog.51cto.com/u_14291117/6168648" target="_blank" title="JavaScript 引擎 V8 执行流程概述">4.JavaScript 引擎 V8 执行流程概述</a>
                    </li>
                    <li>
                        <a href="https://blog.51cto.com/u_15953612/6168758" target="_blank" title="MySQL基础（一）：SQL语句">5.MySQL基础（一）：SQL语句</a>
                    </li>
                </ul>
            </section>
            <section class="common-fix fix-table">
                <!-- 新人活动 -->
                <a class="ac-box mb24" href="https://blog.51cto.com/51ctoblog/5841499#xiang" target="_blank"><img alt="新人福利" src="https://s2.51cto.com/blog/activity/bride/DetailsBride.gif?x-oss-process=image/ignore-error,1"></a>
                <!-- 文章目录 -->
                <div class="common-section common-spacing table-contents common-content-directory">
                    <div class="clearfix common-sub-title">
                        <strong title="文章目录">文章目录</strong>
                    </div>
                    <div class="directory" id="directory-parent1">
                        <ul class="directory-list" id="directory-right">
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h1">
                                                                                分布式锁入门                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h3">
                                                                                超时设置                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h5">
                                                                                释放了不是自己加的锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h7">
                                                                                正确设置锁超时                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h9">
                                                                                加解锁代码位置有讲究                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h11">
                                                                                实现可重入锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h12">
                                                                                Redis Hash 可重入锁                                    </span>
                                </div>
                            </li>
                            <li class="lv3">
                                <div class="title">
                                    <span data-id="#h13">
                                                                                加锁逻辑                                    </span>
                                </div>
                            </li>
                            <li class="lv3">
                                <div class="title">
                                    <span data-id="#h14">
                                                                                解锁逻辑                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h16">
                                                                                主从架构带来的问题                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h18">
                                                                                什么是 Redlock                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h19">
                                                                                Redlock 是与非                                    </span>
                                </div>
                            </li>
                            <li class="lv3">
                                <div class="title">
                                    <span data-id="#h20">
                                                                                Martin 的结论                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h21">
                                                                                Redis 作者 Antirez 的反驳                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h23">
                                                                                Redisson 分布式锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h24">
                                                                                失败无限重试                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h25">
                                                                                失败超时重试，自动续命                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h26">
                                                                                超时自动释放锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h27">
                                                                                超时重试，自动解锁                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h28">
                                                                                Watch Dog 自动延时                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h29">
                                                                                源码导读                                    </span>
                                </div>
                            </li>
                            <li class="lv1">
                                <div class="title">
                                    <span data-id="#h30">
                                                                                、                                    </span>
                                </div>
                            </li>
                            <div class="arrow on" style="top: 596.45px;"></div></ul>
                    </div>
                    <div class="table-contents"></div>
                </div>
            </section>



        </aside>
    </div>
    <!--悬浮小菜单-->
    <aside class="minmenu" style="display: block;">
        <ul>
            <li class="signIn" signid="2">
                <button id="signIn">  每日签到</button>
            </li>
            <li class="editArticle" editid="2">
                <div class="new_bloger ">新人福利</div>
                <button id="editArticle"><i class="iconblog blogxiewz"></i></button>
            </li>
            <li class="scrollToTop">
                <i class="iconblog bloggengduo1"></i>
            </li>
        </ul>
    </aside>
</div>